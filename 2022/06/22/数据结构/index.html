<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>数据结构 | kyrie C</title><meta name="keywords" content="数据结构"><meta name="author" content="小c只会突破"><meta name="copyright" content="小c只会突破"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据结构栈遵循后进先出原则（LIFO） 12345678910111213141516171819202122232425262728293031class Stack &amp;#123;  constructor() &amp;#123;    this.arr &#x3D; []  &amp;#125;  push(elm) &amp;#123;    this.arr.push(elm)  &amp;#125;  pop() &amp;#123;">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构">
<meta property="og:url" content="https://kyriecqy.github.io/2022/06/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="kyrie C">
<meta property="og:description" content="数据结构栈遵循后进先出原则（LIFO） 12345678910111213141516171819202122232425262728293031class Stack &amp;#123;  constructor() &amp;#123;    this.arr &#x3D; []  &amp;#125;  push(elm) &amp;#123;    this.arr.push(elm)  &amp;#125;  pop() &amp;#123;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kyriecqy.github.io/images/logo.jpg">
<meta property="article:published_time" content="2022-06-22T02:36:28.000Z">
<meta property="article:modified_time" content="2022-06-30T08:54:45.765Z">
<meta property="article:author" content="小c只会突破">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kyriecqy.github.io/images/logo.jpg"><link rel="shortcut icon" href="/images/logo.jpg"><link rel="canonical" href="https://kyriecqy.github.io/2022/06/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-30 16:54:45'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/irving.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/bg5.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">kyrie C</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-22T02:36:28.000Z" title="发表于 2022-06-22 10:36:28">2022-06-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-30T08:54:45.765Z" title="更新于 2022-06-30 16:54:45">2022-06-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>遵循后进先出原则（LIFO）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">arr</span> = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">push</span>(<span class="params">elm</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="title function_">push</span>(elm)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> item = <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="title function_">pop</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="property">length</span> === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="property">length</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//返回栈顶元素</span></span><br><span class="line">  <span class="title function_">peek</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">arr</span>[<span class="variable language_">this</span>.<span class="title function_">size</span>() - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>栈的应用</strong></p>
<p>函数调用栈：</p>
<p>例如在函数A中调用了函数B，在函数B中又调用了C<br>那么在执行时，A先压入栈，执行来到调用B的代码，因为A还没有执行完，所以A不会出栈。<br>B被压入栈，同样的，执行来到调用C的代码，因为B还没有执行完，所以B不会出栈。<br>等到C执行完弹栈，B才执行接下来的代码然后也弹栈，A再执行接下来的代码然后弹栈。</p>
<p>导致的问题：有一些函数递归次数过多时，会出现栈溢出的情况<br>解决方法：尾调用优化</p>
<p>十进制转二进制：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dec2bin</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Stack</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> item = num % <span class="number">2</span></span><br><span class="line">    s.<span class="title function_">push</span>(item)</span><br><span class="line"></span><br><span class="line">    num = <span class="title class_">Math</span>.<span class="title function_">floor</span>(num / <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">while</span>(!s.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    res += s.<span class="title function_">pop</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>遵循先进先出原则（FIFO）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">arr</span> = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//尾部添加元素</span></span><br><span class="line">  <span class="title function_">enqueue</span>(<span class="params">elm</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="title function_">push</span>(elm)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//头部移除</span></span><br><span class="line">  <span class="title function_">dequeue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> item = <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="title function_">shift</span>()</span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//返回队列第一个元素</span></span><br><span class="line">  <span class="title function_">front</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">arr</span>[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="property">length</span> === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="property">length</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例题：击鼓传花</p>
<p>描述：几个人围成一圈，开始数数，数到某个数字的人淘汰，最后剩下的人胜出</p>
<p>思路：这个问题用队列可以很好解决，将所有人排出一队，从队头开始数数，没数到指定数字的人出队，然后再入队（就实现了将这个人排到队尾）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">passGame</span>(<span class="params">nameList, num</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> q = <span class="keyword">new</span> <span class="title class_">Queue</span>()</span><br><span class="line">  <span class="comment">//先将名字存入队列</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nameList.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    q.<span class="title function_">enqueue</span>(nameList[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//队列内剩下的人不止一个时，游戏继续</span></span><br><span class="line">  <span class="keyword">while</span>(q.<span class="title function_">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//没数到特定数字的人出队再入队</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; num - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      q.<span class="title function_">enqueue</span>(q.<span class="title function_">dequeue</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数到特定数字的人出队（淘汰）</span></span><br><span class="line">    q.<span class="title function_">dequeue</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> q.<span class="title function_">front</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = [<span class="string">&#x27;kyrie&#x27;</span>, <span class="string">&#x27;harden&#x27;</span>, <span class="string">&#x27;kd&#x27;</span>, <span class="string">&#x27;james&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">passGame</span>(person, <span class="number">5</span>)); <span class="comment">//harden</span></span><br></pre></td></tr></table></figure>

<h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><p>线性表的局限：在开头和中间插入删除数据成本较高</p>
<p>链表特点：存储空间不必一定是连续，在插入删除数据时效率高</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">elm</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">item</span> = elm</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkList</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = <span class="literal">null</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//尾部添加元素</span></span><br><span class="line">  <span class="title function_">append</span>(<span class="params">elm</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(elm)</span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span> = node</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(current.<span class="property">next</span>) &#123;</span><br><span class="line">        current = current.<span class="property">next</span></span><br><span class="line">      &#125;</span><br><span class="line">      current.<span class="property">next</span> = node</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//插入元素</span></span><br><span class="line">  <span class="title function_">insert</span>(<span class="params">elm, pos</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &gt; <span class="variable language_">this</span>.<span class="property">length</span> || pos &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(elm)</span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span></span><br><span class="line">    <span class="keyword">if</span>(pos === <span class="number">0</span>) &#123;</span><br><span class="line">      node.<span class="property">next</span> = current</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span> = node</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//找到目标位置的前一个节点</span></span><br><span class="line">      <span class="keyword">while</span>(pos &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        current = current.<span class="property">next</span></span><br><span class="line">        pos--</span><br><span class="line">      &#125;</span><br><span class="line">      node.<span class="property">next</span> = current.<span class="property">next</span></span><br><span class="line">      current.<span class="property">next</span> = node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//按位置获取元素值</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">pos</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &gt; <span class="variable language_">this</span>.<span class="property">length</span> || pos &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span></span><br><span class="line">    <span class="keyword">while</span>(pos) &#123;</span><br><span class="line">      current = current.<span class="property">next</span></span><br><span class="line">      pos--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current.<span class="property">item</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//更新元素值</span></span><br><span class="line">  <span class="title function_">update</span>(<span class="params">pos, newElm</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> position = pos</span><br><span class="line">    <span class="keyword">if</span>(pos &gt; <span class="variable language_">this</span>.<span class="property">length</span> || pos &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span></span><br><span class="line">    <span class="keyword">while</span>(pos) &#123;</span><br><span class="line">      current = current.<span class="property">next</span></span><br><span class="line">      pos--</span><br><span class="line">    &#125;</span><br><span class="line">    current.<span class="property">item</span> = newElm</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">get</span>(position)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//移除元素</span></span><br><span class="line">  <span class="title function_">remove</span>(<span class="params">pos</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &gt; <span class="variable language_">this</span>.<span class="property">length</span> || pos &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span></span><br><span class="line">    <span class="keyword">while</span>(pos &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      current = current.<span class="property">next</span></span><br><span class="line">      pos--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取目标节点的前一个节点</span></span><br><span class="line">    <span class="keyword">let</span> preNode = current</span><br><span class="line">    <span class="comment">//获取目标节点</span></span><br><span class="line">    current = current.<span class="property">next</span></span><br><span class="line"></span><br><span class="line">    preNode.<span class="property">next</span> = current.<span class="property">next</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>--</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> current.<span class="property">item</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span>(current) &#123;</span><br><span class="line">      res += current.<span class="property">item</span> + <span class="string">&#x27; &#x27;</span></span><br><span class="line">      current = current.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>单向链表只能从头遍历到尾或者从尾遍历到头，在实际开发中经常需要访问当前节点的前一个节点，就十分的麻烦</p>
<p>双向链表中的每一个节点都有向前的引用和向后的引用，可以有效解决单向链表的问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">elm</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">item</span> = elm</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//对前一个节点的引用</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">prev</span> = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoublyLinkList</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = <span class="literal">null</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="literal">null</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//尾部添加节点</span></span><br><span class="line">  <span class="title function_">append</span>(<span class="params">elm</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(elm)</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span> = <span class="variable language_">this</span>.<span class="property">tail</span> = node</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      node.<span class="property">prev</span> = <span class="variable language_">this</span>.<span class="property">tail</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span>.<span class="property">next</span> = node</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span> = node</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//插入节点</span></span><br><span class="line">  <span class="title function_">insert</span>(<span class="params">elm, pos</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &gt; <span class="variable language_">this</span>.<span class="property">length</span> || pos &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(elm)</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span> = <span class="variable language_">this</span>.<span class="property">tail</span> = node</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(pos === <span class="number">0</span>) &#123;</span><br><span class="line">        node.<span class="property">next</span> = <span class="variable language_">this</span>.<span class="property">head</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">prev</span> = node</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span> = node</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pos === <span class="variable language_">this</span>.<span class="property">length</span>) &#123;</span><br><span class="line">        node.<span class="property">prev</span> = <span class="variable language_">this</span>.<span class="property">tail</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tail</span>.<span class="property">next</span> = node</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tail</span> = node</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span></span><br><span class="line">        <span class="keyword">while</span>(pos--) &#123;</span><br><span class="line">          current = current.<span class="property">next</span></span><br><span class="line">        &#125;</span><br><span class="line">        current.<span class="property">prev</span>.<span class="property">next</span> = node</span><br><span class="line">        node.<span class="property">prev</span> = current.<span class="property">prev</span></span><br><span class="line">        current.<span class="property">prev</span> = node</span><br><span class="line">        node.<span class="property">next</span> = current</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//移除元素</span></span><br><span class="line">  <span class="title function_">remove</span>(<span class="params">pos</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &gt;= <span class="variable language_">this</span>.<span class="property">length</span> || pos &lt; <span class="number">0</span> || <span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">//删除第一个元素，要判断是不是链表中是否只有一个元素</span></span><br><span class="line">    <span class="keyword">if</span>(pos === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span> = <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="literal">null</span></span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">next</span>.<span class="property">prev</span> = <span class="literal">null</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span> = <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">next</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//删除最后一个元素</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pos === <span class="variable language_">this</span>.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span>.<span class="property">prev</span>.<span class="property">next</span> = <span class="literal">null</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="variable language_">this</span>.<span class="property">tail</span>.<span class="property">prev</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span></span><br><span class="line">      <span class="keyword">while</span>(pos--) &#123;</span><br><span class="line">        current = current.<span class="property">next</span></span><br><span class="line">      &#125;</span><br><span class="line">      current.<span class="property">prev</span>.<span class="property">next</span> = current.<span class="property">next</span></span><br><span class="line">      current.<span class="property">next</span>.<span class="property">prev</span> = current.<span class="property">prev</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>--</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">pos</span>) &#123;</span><br><span class="line">    <span class="comment">//和单向链表大同小异，</span></span><br><span class="line">    <span class="comment">//增加了判断pos在整个链表中相对位置，靠前就从头遍历，靠后就从尾遍历</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//从头到尾打印</span></span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">      <span class="keyword">while</span>(current) &#123;</span><br><span class="line">        res += current.<span class="property">item</span> + <span class="string">&#x27; &#x27;</span></span><br><span class="line">        current = current.<span class="property">next</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//从尾到头打印</span></span><br><span class="line">  <span class="title function_">forwardString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">tail</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">      <span class="keyword">while</span>(current) &#123;</span><br><span class="line">        res += current.<span class="property">item</span> + <span class="string">&#x27; &#x27;</span></span><br><span class="line">        current = current.<span class="property">prev</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>数组在进行一些操作时有明显的不足，例如插入和删除效率较低，按内容查找效率也低（要遍历），按索引查找的效率是很高的。</p>
<p><strong>哈希表</strong>通常是基于数组实现的，相对于数组的优势：</p>
<ol>
<li>它可以非常快速的插入删除查找</li>
<li>无论多少数据，插入与删除的时间都接近O(1)的时间级</li>
<li>比树还要快</li>
</ol>
<p>不足：</p>
<ol>
<li>哈希表中的数据没有顺序</li>
<li>通常情况下，哈希表中的key不允许重复</li>
</ol>
<p><strong>理解哈希函数</strong></p>
<p>来设想下面的场景：我们有一个公司，有2000个员工。每个员工都有自己的编号，现在我们只知道员工的名字，要查找这个员工的信息。</p>
<p>如果用数组来存储这些员工的信息（假设编号就对应着在数组中的下标），那么根据名字查找（也就是根据内容查找）复杂的还是十分的高。<br>链表就更不用说了，连用编号查找都费劲。</p>
<p>那我们有没有一种方法，在我们知道员工的名字时，就可以根据名字对应出它的编号，然后用编号（也就是索引）在数组中查找。</p>
<p>这就是<strong>哈希函数</strong>要干的事情</p>
<p>哈希函数的尝试：</p>
<ol>
<li>方案一：单词转数字<br>例如员工的名字是aa，类似于asc编码一样，<br>我们将a&#x3D;1，b&#x3D;2 ….以此类推，可以算出aa对应的值是2，<br>那么它就存放在数组中下标为2的位置。<br>这个方案的缺点就是数字太小很容易重复，例如b员工的下标也应该是2，那么就冲突了</li>
<li>方案二：幂的连乘<br>例如员工的名字是cba，使用幂的连乘：3<em>10^2 + 2</em>10^1 + 1*10^0<br>这样求得的数字就基本避免了重复的问题，<br>但是数字太大又导致开辟的数组消耗太多内存，并且会有许多浪费</li>
</ol>
<p><strong>理解哈希化</strong><br>现在需要一种压缩方法，能将幂的连乘得到的巨大数组压缩成一个可接受范围内的数组</p>
<p>有一种简单的压缩方法就是使用<strong>取余</strong>，它的作用是得到一个数被另一个数整除后的余数</p>
<p><strong>取余操作的实现</strong></p>
<p>假设我们要将0<del>199之间的数字，压缩为0</del>9的范围<br>所以下标的结果 <code>index = LargeNumber % SmallNumber</code><br>例如 157 % 10 &#x3D; 7</p>
<p>这样转化之后还是会有重复，但是重复的概率明显变小。</p>
<p><strong>概念总结</strong><br>哈希化：将大数字转化成数组范围内下标的过程<br>哈希函数：将单词转化成大数字，大数字在进行哈希化的过程<br>哈希表：将数据插入到这个数组，对整个结构的封装</p>
<p>对于不可避免的下标冲突，我们一般用以下的方法：</p>
<ol>
<li>链地址法</li>
<li>开放地址法</li>
</ol>
<p><strong>链地址法</strong><br>链地址法解决冲突的办法是每个数组单元中存储的不是单个数据，而是一个链条<br>链条常用的数组或者链表<br>当查询时，先根据哈希化后的下标值找到对应的位置，再取出链表，依次查询要找的数据</p>
<p>至于是使用数组还是链表，视实际情况而定。例如：你想将新插入的数据放到链的前面，可能新插入的数据用到的概率大，赭红情况链表最好。数组要将整体数据后移比较复杂</p>
<p><img src="./hash.png"></p>
<p><strong>开放地址法</strong><br>开放地址法的主要工作方式是寻找空白的单元格来添加数据</p>
<p>主要分为三种探测方法：</p>
<ol>
<li>线性探测</li>
<li>二次探测</li>
<li>再哈希法</li>
</ol>
<p><strong>线性探测</strong></p>
<ol>
<li>插入<br>例如我们在数组中下标为2的位置以及存储了哈希化之后的82<br>这个时候我们又要插入哈希化之后的32，但发现下标为2的位置已经被占了，<br>线性探测就从<strong>下标+1</strong>的位置开始查找是否有还未插入数据的位置<br>在下面的例子中，我们发现下标为3的位置空着，就将32存进去<br><img src="./hash2.png"></li>
<li>查询<br>查询和插入相似，首先哈希化32之后知道要查询下标为2的位置<br>发现存着的是82，那就从<strong>下标+1</strong>的位置开始查询，发现下标为3的就是32，这样就查询到了结果<br>查询过程有一个约定，就是查询到空位置，就停止（因为线性插入寻找的是最近的空位置存入，不可能跳过一些空格不存）</li>
<li>删除<br>删除和插入查询类型，<br>但是需要注意的是：删除一项时，要将这个位置的内容设置为-1，而不是空。<br>因为他会影响我们对其他数据的查询。例如我们先删除了82，并将他的位置设置为空，然后我们来查找32，发现下标为2的位置为空，根据插入的规则可以知道中间不可能有空位置，这样会导致32实际存在但是访问不到</li>
</ol>
<p>线性探测的问题（集聚问题）：例如我们插入一连串的22，23，24，25，这就意味着下标2，3，4，5都存了元素。当我们要插入32时，发现一连串的单元都不允许我们放置，这样需要探索很多次</p>
<p><strong>二次探测</strong></p>
<p>二次探测是在线性探测的基础上进行了优化，优化的主要是探测步长<br>线性探测的步长为1，<br>二次探测，例如从下标x开始，x+1^2, x+2^2,x+3^2<br>这样就可以一次性探测比较长的距离，避免了线性探测的聚焦</p>
<p>二次探测问题：还是会出现步长不一的聚焦</p>
<p><strong>再哈希法</strong></p>
<p>再哈希法的主要思想是：相同的数据被映射到相同的数组下标，但是使用的是不同的探测步长<br>做法：将数据用另外一个哈希函数再做一次哈希，将这次的哈希结果作为步长</p>
<p>第二次哈希化的特点：</p>
<ol>
<li>与第一个哈希函数不同，不然结果还是一样</li>
<li>不能输出为0，即步长不能是0，不然就死循环了</li>
</ol>
<p>前人已经设计出一种很好的哈希函数：<br><code>stepSize = constant - ( key - constant )</code><br>其中<code>constant</code>是一个<strong>质数</strong>，且小于数组的容量。<code>key</code>就是要哈希的数据</p>
<h3 id="哈希化效率"><a href="#哈希化效率" class="headerlink" title="哈希化效率"></a>哈希化效率</h3><p>在没有产生冲突时，效率是非常高的。发生冲突时，效率依赖探测长度</p>
<p>平均探测长度以及平均存取时间，取决于填装因子。填装因子越大，探测长度也越大<br><strong>填装因子</strong><br>就是哈希表中数据量和哈希表长度阿比值（填装因子 &#x3D; 数据量 &#x2F; 哈希表长度）<br>链地址法的填装因子可以大于1，因为链后面可能一直链下去<br>开发地址法的填装因子最大是1，因为它必须找空位来添加数据</p>
<p><strong>注意：</strong> 在开发地址法中哈希表的长度0、幂的连乘的底数和再哈希之后的步长最好使用<strong>质数</strong>，它可以提高开发地址法的效率。</p>
<h3 id="哈希函数书写"><a href="#哈希函数书写" class="headerlink" title="哈希函数书写"></a>哈希函数书写</h3><p>一个优秀的哈希函数要尽量少的使用乘法和除法，因为计算机处理乘除法效率较低。<br>将哈希函数的尝试二中的表达式进行抽象：<code>a(n)x^n + a(n-1)x^(n-1) + ... + a(1)x + a(0)</code><br>可以知道的是，上面的式子中乘法的次数是<code>n(n+1)/2</code>次，加法是<code>n</code>次。显然效率不会很高，不是一个好的选择</p>
<p>所以我们需要将这个多项式进行优化，处理这类问题有一个高效的算法：<strong>霍纳法则</strong><br>我们用上面式子中的前两项<code>a(n)x^n +a(n-1)x^(n-1)</code>来说明，<br>可以发现它们有公因数可以提取，提取之后就变成了：<code>( a(n)x + a(n-1) )x^(n-1)</code><br>就这两项的合并就减少了n次的乘法，提示了计算效率</p>
<p>这就是霍纳法则的思路，最后我们就原多项式提取为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((...((( a(n)x + a(n) - 1)x + a(n-2))x + a(n-3))...)x + a1)x + a0</span><br></pre></td></tr></table></figure>
<p>这样变换之后我们只需要乘法<code>N</code>次，加法<code>N</code>次</p>
<p>代码实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 哈希函数</span></span><br><span class="line"><span class="comment"> * str：要哈希的字符串</span></span><br><span class="line"><span class="comment"> * size：可接受的数组长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hashFunc</span>(<span class="params">str, size</span>) &#123;</span><br><span class="line">  <span class="comment">//将字符串转成的较大数字存储在hashCode</span></span><br><span class="line">  <span class="keyword">let</span> hashCode = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//charCodeAt()可以获取到字符的Unicode编码</span></span><br><span class="line">    <span class="comment">//借用Unicode编码来实现单词转数字操作</span></span><br><span class="line">    <span class="comment">//这个就是霍纳法则的表达式</span></span><br><span class="line">    hashCode = <span class="number">37</span> * hashCode + str.<span class="title function_">charCodeAt</span>(i)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//取余操作</span></span><br><span class="line">  <span class="keyword">let</span> index = hashCode % size</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> index</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hashFunc</span>(<span class="string">&#x27;cqy&#x27;</span>, <span class="number">11</span>)); <span class="comment">//1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hashFunc</span>(<span class="string">&#x27;kyrie&#x27;</span>, <span class="number">11</span>)); <span class="comment">//4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hashFunc</span>(<span class="string">&#x27;kd&#x27;</span>, <span class="number">11</span>)); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<h3 id="实现哈希表"><a href="#实现哈希表" class="headerlink" title="实现哈希表"></a>实现哈希表</h3><p>我们采用链地址法来实现哈希表，而哈希表中的每个index都使用数组来实现（就是链出来的链条）。在这个数组中一对一对的存放着哈希化后的值和原来的字符串<br><img src="./hash3.png"></p>
<p><strong>创建哈希表类</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">length</span>) &#123;</span><br><span class="line">    <span class="comment">//存放哈希表中相应的数据</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">storage</span> = []</span><br><span class="line">    <span class="comment">//记录存储了多少数据，用于后面计算填充因子</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span></span><br><span class="line">    <span class="comment">//哈希表的长度</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">limit</span> = length</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//哈希函数</span></span><br><span class="line">  <span class="title function_">hashFunc</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> hashCode = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      hashCode = <span class="number">37</span> * hashCode + str.<span class="title function_">charCodeAt</span>(i)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">let</span> index = hashCode % <span class="variable language_">this</span>.<span class="property">limit</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> index</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>添加&amp;修改数据</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入&amp;修改数据</span></span><br><span class="line"><span class="title function_">put</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">  <span class="comment">//获得哈希化之后的下标</span></span><br><span class="line">  <span class="keyword">let</span> index = <span class="variable language_">this</span>.<span class="title function_">hashFunc</span>(key)</span><br><span class="line">  <span class="comment">//判断哈希表中这个下标是否有数据，</span></span><br><span class="line">  <span class="comment">//没有的话创建一个bucket（链条）来存储这个下标下的数据</span></span><br><span class="line">  <span class="keyword">let</span> bucket = <span class="variable language_">this</span>.<span class="property">storage</span>[index]</span><br><span class="line">  <span class="keyword">if</span>(!bucket) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">storage</span>[index] = bucket = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//判断是否是修改数据</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> tuple = bucket[i]</span><br><span class="line">    <span class="keyword">if</span>(tuple[<span class="number">0</span>] == key) &#123;</span><br><span class="line">      tuple[<span class="number">1</span>] = value</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//不是修改，是添加数据</span></span><br><span class="line">  bucket.<span class="title function_">push</span>([key, value])</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">count</span>++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取数据</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取数据</span></span><br><span class="line"><span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="variable language_">this</span>.<span class="title function_">hashFunc</span>(key)</span><br><span class="line">  <span class="comment">//根据下标获取哈希表中的bucket</span></span><br><span class="line">  <span class="keyword">let</span> bucket = <span class="variable language_">this</span>.<span class="property">storage</span>[index]</span><br><span class="line">  <span class="comment">//如果key存在，返回它对应阿value</span></span><br><span class="line">  <span class="keyword">if</span>(bucket) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> tuple = bucket[i]</span><br><span class="line">      <span class="keyword">if</span>(tuple[<span class="number">0</span>] == key) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`找到了<span class="subst">$&#123;key&#125;</span>对应的数据: <span class="subst">$&#123;tuple[<span class="number">1</span>]&#125;</span>`</span>)</span><br><span class="line">        <span class="comment">//将数据返回</span></span><br><span class="line">        <span class="keyword">return</span> tuple[<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//key不存在</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`没有找到<span class="subst">$&#123;key&#125;</span>对应的数据`</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除数据</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除数据</span></span><br><span class="line"><span class="title function_">delete</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="comment">//借助get()方法</span></span><br><span class="line">  <span class="keyword">let</span> res = <span class="variable language_">this</span>.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="comment">//如果数据存在</span></span><br><span class="line">  <span class="keyword">if</span>(res) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="variable language_">this</span>.<span class="title function_">hashFunc</span>(key)</span><br><span class="line">    <span class="keyword">let</span> bucket = <span class="variable language_">this</span>.<span class="property">storage</span>[index]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> tuple = bucket[i]</span><br><span class="line">      <span class="keyword">if</span>(tuple[<span class="number">0</span>] = key) &#123;</span><br><span class="line">        <span class="comment">//删除对应的数据项</span></span><br><span class="line">        bucket[i].<span class="title function_">splice</span>(i, <span class="number">1</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">count</span>--</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其他方法</strong></p>
<p>其他例如查看哈希表长度和是否为空等，只要用<code>this.count</code>进行判断就可以了</p>
<h3 id="哈希表的扩容"><a href="#哈希表的扩容" class="headerlink" title="哈希表的扩容"></a>哈希表的扩容</h3><p><strong>为什么要扩容?</strong><br>我们使用的是链地址法，它的填装因子（loadFactor）可以大于1，所以可以无限的插入数据<br>但是当数据量增多，每一个下标对应的bucket的数据量也增多，查找效率会降低</p>
<p><strong>如何扩容?</strong><br>扩容可以简单的将容量增大两倍（当然使扩容后容量还是质数是最好的）<br>除此之外，每一个数据进行移动（重新调用哈希函数）。<br>比如hashCode&#x3D;12的数据，在limit&#x3D;8时存放在下标为4处，在limit&#x3D;16时就要存放在下标为12处了</p>
<p><strong>什么情况扩容?</strong><br>比较常见的情况是<code>loadFactor &gt; 0.75</code>时进行扩容</p>
<p><strong>代码实现</strong><br>可以自己手动调用扩容函数，也可以在put方法中判断并调用来扩容，在delect方法中判断并调用来缩容</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回填装因子</span></span><br><span class="line"><span class="title function_">loadFactor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span> !== <span class="number">0</span> ? (<span class="variable language_">this</span>.<span class="property">count</span> / <span class="variable language_">this</span>.<span class="property">limit</span>).<span class="title function_">toFixed</span>(<span class="number">2</span>) : <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容</span></span><br><span class="line"><span class="title function_">resize</span>(<span class="params">newLimit</span>) &#123;</span><br><span class="line">  <span class="comment">//保存旧的storage</span></span><br><span class="line">  <span class="keyword">let</span> oldStorage = <span class="variable language_">this</span>.<span class="property">storage</span></span><br><span class="line">  <span class="comment">//初始化扩容后的哈希表</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">storage</span> = []</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">limit</span> = newLimit</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; oldStorage.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> bucket =oldStorage[i]</span><br><span class="line">    <span class="comment">//如果这个bucket为空，则跳出这一次循环，来到下一次循环</span></span><br><span class="line">    <span class="keyword">if</span>(!bucket) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; bucket.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> tuple = bucket[j]</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">put</span>(...tuple)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>将扩容长度转为质数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断质数</span></span><br><span class="line"><span class="title function_">isPrime</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> temp = <span class="built_in">parseInt</span>(<span class="title class_">Math</span>.<span class="title function_">sqrt</span>(num))</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; temp; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(num % i == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回质数</span></span><br><span class="line"><span class="title function_">getPrime</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span>(!<span class="variable language_">this</span>.<span class="title function_">isPrime</span>(num)) &#123;</span><br><span class="line">    num++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩容</span></span><br><span class="line"><span class="title function_">resize</span>(<span class="params">newLimit</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> oldStorage = <span class="variable language_">this</span>.<span class="property">storage</span></span><br><span class="line">  <span class="comment">//将传入的容量转化为质数</span></span><br><span class="line">  <span class="keyword">let</span> primeLimit = <span class="variable language_">this</span>.<span class="title function_">getPrime</span>(newLimit) <span class="comment">//(*)</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">storage</span> = []</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">limit</span> = primeLimit <span class="comment">//(*)</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完整哈希表代码"><a href="#完整哈希表代码" class="headerlink" title="完整哈希表代码"></a>完整哈希表代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">length</span>) &#123;</span><br><span class="line">    <span class="comment">//存放哈希表中相应的数据</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">storage</span> = []</span><br><span class="line">    <span class="comment">//记录存储了多少数据，用于后面计算填充因子</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span></span><br><span class="line">    <span class="comment">//哈希表的长度</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">limit</span> = length</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//哈希函数</span></span><br><span class="line">  <span class="title function_">hashFunc</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> hashCode = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      hashCode = <span class="number">37</span> * hashCode + str.<span class="title function_">charCodeAt</span>(i)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">let</span> index = hashCode % <span class="variable language_">this</span>.<span class="property">limit</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> index</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//插入&amp;修改数据</span></span><br><span class="line">  <span class="title function_">put</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="variable language_">this</span>.<span class="title function_">hashFunc</span>(key)</span><br><span class="line">    <span class="comment">//判断哈希表中这个位置是否有数据，没有的话创建一个bucket（链条）</span></span><br><span class="line">    <span class="keyword">let</span> bucket = <span class="variable language_">this</span>.<span class="property">storage</span>[index]</span><br><span class="line">    <span class="keyword">if</span>(!bucket) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">storage</span>[index] = bucket = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否是修改数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> tuple = bucket[i]</span><br><span class="line">      <span class="keyword">if</span>(tuple[<span class="number">0</span>] == key) &#123;</span><br><span class="line">        tuple[<span class="number">1</span>] = value</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不是修改，是添加数据</span></span><br><span class="line">    bucket.<span class="title function_">push</span>([key, value])</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取数据</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="variable language_">this</span>.<span class="title function_">hashFunc</span>(key)</span><br><span class="line">    <span class="comment">//根据下标获取哈希表中的bucket</span></span><br><span class="line">    <span class="keyword">let</span> bucket = <span class="variable language_">this</span>.<span class="property">storage</span>[index]</span><br><span class="line">    <span class="comment">//如果key存在，返回它对应阿value</span></span><br><span class="line">    <span class="keyword">if</span>(bucket) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> tuple = bucket[i]</span><br><span class="line">        <span class="keyword">if</span>(tuple[<span class="number">0</span>] == key) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`找到了<span class="subst">$&#123;key&#125;</span>对应的数据: <span class="subst">$&#123;tuple[<span class="number">1</span>]&#125;</span>`</span>)</span><br><span class="line">          <span class="comment">//将数据返回</span></span><br><span class="line">          <span class="keyword">return</span> tuple[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//key不存在</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`没有找到<span class="subst">$&#123;key&#125;</span>对应的数据`</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//删除数据</span></span><br><span class="line">  <span class="title function_">delete</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="variable language_">this</span>.<span class="title function_">get</span>(key)</span><br><span class="line">    <span class="keyword">if</span>(res) &#123;</span><br><span class="line">      <span class="keyword">let</span> index = <span class="variable language_">this</span>.<span class="title function_">hashFunc</span>(key)</span><br><span class="line">      <span class="keyword">let</span> bucket = <span class="variable language_">this</span>.<span class="property">storage</span>[index]</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> tuple = bucket[i]</span><br><span class="line">        <span class="keyword">if</span>(tuple[<span class="number">0</span>] = key) &#123;</span><br><span class="line">          <span class="comment">//删除对应的数据项</span></span><br><span class="line">          bucket[i].<span class="title function_">splice</span>(i, <span class="number">1</span>)</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">count</span>--</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//返回填装因子</span></span><br><span class="line">  <span class="title function_">loadFactor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span> !== <span class="number">0</span> ? (<span class="variable language_">this</span>.<span class="property">count</span> / <span class="variable language_">this</span>.<span class="property">limit</span>).<span class="title function_">toFixed</span>(<span class="number">2</span>) : <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//判断质数</span></span><br><span class="line">  <span class="title function_">isPrime</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = <span class="built_in">parseInt</span>(<span class="title class_">Math</span>.<span class="title function_">sqrt</span>(num))</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; temp; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(num % i == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//返回质数</span></span><br><span class="line">  <span class="title function_">getPrime</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="variable language_">this</span>.<span class="title function_">isPrime</span>(num)) &#123;</span><br><span class="line">      num++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//扩容</span></span><br><span class="line">  <span class="title function_">resize</span>(<span class="params">newLimit</span>) &#123;</span><br><span class="line">    <span class="comment">//保存旧的storage</span></span><br><span class="line">    <span class="keyword">let</span> oldStorage = <span class="variable language_">this</span>.<span class="property">storage</span></span><br><span class="line">    <span class="comment">//将传入的容量转化为质数</span></span><br><span class="line">    <span class="keyword">let</span> primeLimit = <span class="variable language_">this</span>.<span class="title function_">getPrime</span>(newLimit)</span><br><span class="line">    <span class="comment">//初始化扩容后的哈希表</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">storage</span> = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">limit</span> = primeLimit</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; oldStorage.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> bucket =oldStorage[i]</span><br><span class="line">      <span class="comment">//如果这个bucket为空，则跳出这一次循环，来到下一次循环</span></span><br><span class="line">      <span class="keyword">if</span>(!bucket) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; bucket.<span class="property">length</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">let</span> tuple = bucket[j]</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">put</span>(...tuple)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树的一些术语：<br><strong>节点的度：</strong> 节点的子树个数<br><strong>树的度：</strong> 树的所有节点中最大的度数</p>
<p>几乎所有的树都可以转化为二叉树</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>特性：</p>
<ol>
<li>一个二叉树第i层的最大节点数为<code>2^(i-1)</code></li>
<li>深度为k的二叉树有最大节点总数为<code>2^k - 1</code></li>
<li>任意非空二叉树，若<code>n0</code>表示叶节点个数，<code>n2</code>表示度为2的节点个数，那么满足<code>n0 = n2 + 1</code></li>
</ol>
<p><strong>完美二叉树（满二叉树）</strong> 除叶节点外，每层节点都有2个子节点<br><strong>完全二叉树</strong> 最后一层叶节点从左到右连续存在，只缺右侧若干节点</p>
<p>完美二叉树是特殊的完全二叉树</p>
<p><strong>二叉树的存储</strong><br>常见的有数组和链表<br>数组对于完全二叉树比较友好，直接从上到下，从左到右将节点依次存入数据<br>但对于非完全二叉树，用数组存储会浪费许多的空间（要用空节点将非完全二叉树补成完全二叉树）</p>
<p>所以一般都使用链表来表示</p>
<h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>二叉搜索（排序|查找）树（BST，Binary Search Tree）<br>性质：</p>
<ol>
<li>非空左子树的所有键值小于其根节点的键值</li>
<li>非空右子树的所有键值大于其根节点的键值</li>
<li>左右子树本身也是二叉搜索树</li>
</ol>
<p>如下图，左边的不是BST，因为右子树键值3小于其根节点10。右边的是BST<br><img src="./bst.png"></p>
<p>BST的特点就是相对较小的指总是保存在左节点，查找效率高<br><img src="./bst2.png"><br>例如我们要查找19，明显19大于根节点18，所以我们只需要查找右子树，以此类推找到19。</p>
<p><strong>插入</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = key</span><br><span class="line">    <span class="comment">//左孩子和右孩子</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = <span class="literal">null</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">right</span> = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">insert</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(key)</span><br><span class="line">    <span class="comment">//判断是否是空树</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = node</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, node)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//递归此方法来找到要插入的位置并插入节点</span></span><br><span class="line">  <span class="title function_">insertNode</span>(<span class="params">node, newNode</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(node.<span class="property">key</span> &gt; newNode.<span class="property">key</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!node.<span class="property">left</span>) &#123;</span><br><span class="line">        node.<span class="property">left</span> = newNode</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(node.<span class="property">left</span>, newNode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!node.<span class="property">right</span>) &#123;</span><br><span class="line">        node.<span class="property">right</span> = newNode</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(node.<span class="property">right</span>, newNode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>遍历</strong><br>树的遍历常用的有三种：先序遍历，中序遍历，后序遍历</p>
<p><strong>先序遍历</strong><br>从根开始，先遍历根节点，再遍历左子树和右子树</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//handler为遍历之后打印的方式</span></span><br><span class="line"><span class="title function_">preOrderTraversal</span>(<span class="params">handler</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">preOrderTraversalNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, handler)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">preOrderTraversalNode</span>(<span class="params">node, handler</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(node) &#123;</span><br><span class="line">    <span class="title function_">handler</span>(node.<span class="property">key</span>)</span><br><span class="line">    <span class="comment">//先遍历左子树再遍历右子树</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">preOrderTraversalNode</span>(node.<span class="property">left</span>, handler)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">preOrderTraversalNode</span>(node.<span class="property">right</span>, handler)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bst = <span class="keyword">new</span> <span class="title class_">BinarySearchTree</span>()</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">5</span>)</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">4</span>)</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">3</span>)</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">6</span>)</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">8</span>)</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">11</span>)</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">7</span>)</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">bst.<span class="title function_">preOrderTraversal</span>(<span class="keyword">function</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  res += key + <span class="string">&#x27; &#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">//5 4 3 2 6 8 7 11 </span></span><br></pre></td></tr></table></figure>

<p><strong>中序遍历</strong><br>先中序遍历左子树，再遍历根节点，最后中序遍历右子树</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">midOrderTraversal</span>(<span class="params">handler</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">midOrderTraversalNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, handler)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">midOrderTraversalNode</span>(<span class="params">node, handler</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(node) &#123;</span><br><span class="line">    <span class="comment">//只需要在先序的基础上调换遍历左子树和根节点的顺序</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">midOrderTraversalNode</span>(node.<span class="property">left</span>, handler)</span><br><span class="line">    <span class="title function_">handler</span>(node.<span class="property">key</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">midOrderTraversalNode</span>(node.<span class="property">right</span>, handler)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>后序遍历</strong><br>先后序遍历左子树，再后序遍历右子树，最后遍历根节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">postOrderTraversal</span>(<span class="params">handler</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">postOrderTraversalNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, handler)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">postOrderTraversalNode</span>(<span class="params">node, handler</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(node) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">postOrderTraversalNode</span>(node.<span class="property">left</span>, handler)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">postOrderTraversalNode</span>(node.<span class="property">right</span>, handler)</span><br><span class="line">    <span class="title function_">handler</span>(node.<span class="property">key</span>)</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>寻找最大最小值</strong><br>由BST的性质可知，最小值一定在树的最左边的叶节点，最大值一定在树的最右边的叶节点<br>所以只需要一直遍历左节点就可以找到最小值，一直遍历右节点就可以找到最大值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">max</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">root</span></span><br><span class="line">  <span class="keyword">while</span>(node.<span class="property">right</span>) &#123;</span><br><span class="line">    node = node.<span class="property">right</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> node.<span class="property">key</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">min</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">root</span></span><br><span class="line">  <span class="keyword">while</span>(node.<span class="property">left</span>) &#123;</span><br><span class="line">    node = node.<span class="property">left</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> node.<span class="property">key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>查找特定key</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">search</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">root</span></span><br><span class="line">  <span class="keyword">while</span>(node) &#123;</span><br><span class="line">    <span class="keyword">if</span>(key &lt; node.<span class="property">key</span>) &#123;</span><br><span class="line">      node = node.<span class="property">left</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &gt; <span class="variable language_">this</span>.<span class="property">key</span>) &#123;</span><br><span class="line">      node = node.<span class="property">right</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除</strong><br>删除节点一般分为三种情况：删除叶节点、删除只有一个子节点的节点、删除有两个子节点的节点</p>
<p>前面两种情况相对简单一些，下面是具体代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">remove</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">root</span></span><br><span class="line">    <span class="keyword">let</span> parent = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//用于标记要删除节点是父节点的左子节点还是右子节点</span></span><br><span class="line">    <span class="keyword">let</span> isLeftChild</span><br><span class="line">    <span class="comment">//1.寻找要删除的节点</span></span><br><span class="line">    <span class="keyword">while</span>(current.<span class="property">key</span> != key) &#123;</span><br><span class="line">      parent = current</span><br><span class="line">      <span class="keyword">if</span>(key &lt; current.<span class="property">key</span>) &#123;</span><br><span class="line">        isLeftChild = <span class="literal">true</span></span><br><span class="line">        current = current.<span class="property">left</span></span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        isLeftChild = <span class="literal">false</span></span><br><span class="line">        current = current.<span class="property">right</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//没有找到节点，返回false</span></span><br><span class="line">      <span class="keyword">if</span>(current = <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.1 要删除的是叶子节点</span></span><br><span class="line">    <span class="keyword">if</span>(current.<span class="property">left</span> == <span class="literal">null</span> | current.<span class="property">right</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(current == <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span></span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild) &#123;</span><br><span class="line">        parent.<span class="property">left</span> = <span class="literal">null</span></span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        parent.<span class="property">right</span> = <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2要删除的节点只有一个子节点</span></span><br><span class="line">    <span class="comment">//要删除节点没有右节点的情况</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(current.<span class="property">right</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(current == <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">root</span> = current.<span class="property">left</span></span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild) &#123;</span><br><span class="line">        parent.<span class="property">left</span> = current.<span class="property">left</span></span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        parent.<span class="property">right</span> = current.<span class="property">left</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//要删除节点没有左节点的情况</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(current.<span class="property">left</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(current == <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">root</span> = current.<span class="property">right</span></span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild) &#123;</span><br><span class="line">        parent.<span class="property">left</span> = current.<span class="property">right</span></span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        parent.<span class="property">right</span> = current.<span class="property">right</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>要删除节点有两个子节点的情况就要复杂许多，来看下图<br><img src="./bst3.png"></p>
<p>例如我们要删除13这个节点，那么就需要从它的子节点中选一个来与13的父节点15相连。在这里显然12或14都可以。选12时，14就变成12的右子节点；选14时，12就变成14的左子节点。</p>
<p>例如我们要删除20这个节点，同样需要从它的后代节点中选一个来连接15。选18的话，19作为18的左子节点就违背了BST的性质。除此之外19和25都可以</p>
<p>例如我们删除15节点，从左子树找一个来顶替它的位置，就应该找14；从右子树找一个就应该是18</p>
<p>综上所述，选择顶替节点的标准就是<strong>左大右小</strong>（从左子树选最大的，从右子树选最小的）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.3删除的节点有两个子节点</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> successor = <span class="variable language_">this</span>.<span class="title function_">getSuccessor</span>(current)</span><br><span class="line">  <span class="keyword">if</span>(current == <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = successor</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild) &#123;</span><br><span class="line">    parent.<span class="property">left</span> = successor</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    parent.<span class="property">right</span> = successor</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将要删除节点的左子树连到替换节点的左节点上</span></span><br><span class="line">  successor.<span class="property">left</span> = current.<span class="property">left</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在右子树找替换值</span></span><br><span class="line"><span class="title function_">getSuccessor</span>(<span class="params">delNode</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> successor = delNode</span><br><span class="line">  <span class="keyword">let</span> current = delNode.<span class="property">right</span></span><br><span class="line">  <span class="keyword">let</span> successorParent = delNode</span><br><span class="line">  <span class="keyword">while</span>(current != <span class="literal">null</span>) &#123;</span><br><span class="line">    successorParent = successor</span><br><span class="line">    successor = current</span><br><span class="line">    <span class="comment">//右子树找的是最小值，所以肯定是在左节点上</span></span><br><span class="line">    current = current.<span class="property">left</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果找到的替换节点不是要删除节点的直接右子节点</span></span><br><span class="line">  <span class="comment">//那么需要将删除节点的子节点连接到替换节点上</span></span><br><span class="line">  <span class="keyword">if</span>(successor != delNode.<span class="property">right</span>) &#123;</span><br><span class="line">    <span class="comment">//将替换节点的子节点与替换节点的父节点相连</span></span><br><span class="line">    <span class="comment">//只需要连替换节点的右子节点的原因是：</span></span><br><span class="line">    <span class="comment">//在右边是找的最小值，而最小值出现在节点的左子节点上</span></span><br><span class="line">    <span class="comment">//因为替换节点一定是最小的，所以它的左子节点一定为空</span></span><br><span class="line">    successorParent.<span class="property">left</span> = successor.<span class="property">right</span></span><br><span class="line">    <span class="comment">//将删除节点的右子树连接到替换节点的右子树</span></span><br><span class="line">    successor.<span class="property">right</span> = delNode.<span class="property">right</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> successor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二叉搜索树总结：</strong><br>优点：二叉搜索树可以很快速的插入和删除给定的数据项，效率大约为O(logN)<br>缺点：当插入连续的数据时会引起二叉树的不平衡。例如我们插入9、8、7、6，根据性质可知，它们会连成如图所示的二叉树，如果在这种情况下查找6，效率和链表是几乎一致的O(N)<br><img src="./bst4.png"><br>对于这种分布不均匀的树被称为<strong>非平衡树</strong>，它的效率与平衡树相比并不高。<br>所以我们要使树的左边节点个数尽可能等于右边节点个数，这样效率才能达到O(logN)</p>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>红黑树可以解决BST的一些缺陷，红黑树除了符合BST的基本规则外，还有一些自己的规则<br>红黑树的规则：</p>
<ol>
<li>节点是红色或黑色</li>
<li>根节点是黑色</li>
<li>每个叶子节点都是黑色的空节点（NIL节点）</li>
<li>每个红色节点的两个子节点都是黑色（也就是说，从每个叶节点到根的路径上不能有两个连续的红色节点）</li>
<li>从任一节点到其每个叶节点的所有路径包含相同数量的黑色节点</li>
</ol>
<p><img src="./hhs.png"></p>
<p><strong>红黑树的规则保证了它从根到叶子的最长可能路径，不会超过最短可能路径的两倍</strong>。这样树就做到了基本平衡，即使最坏的情况下效率依然是高的</p>
<p>最长路径不超过最短路径两倍原因：<br>性质4决定不能有两个或多个相连的红色节点，所以最长路径是红色和黑色交替的。最短路径可能都是黑色节点。<br>性质5让所有路径的黑色节点树都相同，结合性质4、5就可以看出最长路径不超过最短路径两倍</p>
<p>插入一个新节点时，有可能树不再平衡，可以通过三种方式（变色，左旋转，右旋转）的变化，来使树保持平衡<br>首先，插入的新节点通常是红色节点，理由：</p>
<ol>
<li>插入节点为红色时，有可能不违反红黑树规则（例如我们插入一个14到上图的红黑树，我们只需要将14作为15的左子节点，然后再给14添加两个黑色的空节点）</li>
<li>插入黑色节点，必定使某些路径上多出一个黑色节点，会违反性质5</li>
</ol>
<p>红色节点可能会导致红红相连，这种情况就需要通过变色和旋转来调整了</p>
<p><strong>变色</strong><br>为了重新符合红黑树规则，尝试将红色节点变成黑色节点，或将黑色节点变为红色节点</p>
<p><strong>左旋转</strong><br>逆时针旋转红黑树的两个节点，使父节点被自己的右孩子取代，而自己成为自己的左孩子<br><img src="./hhs2.png"><br>上图中，右孩子y取代了x，而x变成了y的左孩子</p>
<p><strong>右旋转</strong><br>顺时针旋转红黑树的两个节点，使父节点被自己的左孩子取代，而自己成为自己的右孩子<br><img src="./hhs3.png"><br>上图中，左孩子y取代了x，而x变成了y的右孩子</p>
<h4 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h4><p>我们设要插入的节点为N，其父节点为P。其祖父节点为G（p的父节点就是N的祖父节点），p的兄弟节点为U（也就是N的叔节点，G的另一个子节点）</p>
<p><strong>情况一：</strong><br>新节点N插入到空树中，没有父节点。这就情况我们要将原来的红色节点N变换成黑色节点，来满足性质2</p>
<p><strong>情况二：</strong><br>N的父节点P是黑色节点，那么插入红色节点N之后并没有违反性质</p>
<p><strong>情况三：</strong><br>P为红色，U也是红色<br>根据性质可以，如果P，U为红，那么它们的父节点G必定是黑色节点，如下图左边所示。这个时候我们就需要将P，U全变成黑色，同时G变成红色，如下图右边所示<br><img src="./hhs4.png"></p>
<p>但是这样可能会出现问题：如果G的父节点是红色的，那么将G变色之后就违反了性质4。解决方法就是将G以及它的子树看成一个红色节点，将这个红色节点插入到G的父节点之后，按照情况递归处理。如果递归调整颜色 到了根节点，那么就需要旋转了</p>
<p><strong>情况四：</strong><br>P为红色，U为黑色，且N是左孩子<br>首先可知，G是黑色节点。这种情况下，我们要先<strong>将P变成黑色节点，G变成红色节点，然后对P，U，G进行右旋转</strong><br><img src="./hhs5.png"></p>
<p><strong>情况五：</strong><br>P为红色，U为黑色，且N是右孩子<br>我们先将P，N，和p的另一个孩子B进行左旋转，变成如图中间的样子。<br>将P和B看成是一个红色节点，这个红色节点插入到N之后。这就变成了情况四。<br>根据情况四的做法，我们将N变成黑色，G变成红色，然后对N，G，U进行右旋转。这样操作之后就得到如图右边的结果<br><img src="./hhs6.png"></p>
<p><strong>案例：</strong><br>例如我们要插入10，9，8三个数，（下面的描述都省略了空的叶子节点，实际是存在的）<br>首先我们插入10这个红色节点，此时树为空，所以10是作为根节点，根据性质2根必须为黑色，所以将10变色为黑色节点<br>然后插入红色节点9，与10进行对比发现比10小，所以作为10的左孩子，检查发现符合规则，不需要做修改<br>最后插入红色节点8，经对比后作为9的左孩子插入。这个时候发现8和9都是红色节点，违反了性质4。<br>对比发现属于情况四，先将9变成黑色节点，10变成红色节点，然后对8，9，10进行右旋转。<br><img src="./hhs7.png"></p>
<p>通过这个简单的例子可以发现，使用红黑树可以将原本不平衡的二叉树变成相对平衡的二叉树</p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>顶点：表示图中的一个节点<br>边：顶点与顶点之间的连线<br>相邻顶点：由一条边连接在一起的顶点<br>度：一个顶点的度是相邻顶点的数量<br>路径：顶点v1,v2 … vn的一个连续序列<br>无向图和有向图：图的边是否是有方向的<br>无权图和带权图：图的边是否有一定的权重</p>
<h3 id="图的邻接矩阵表示"><a href="#图的邻接矩阵表示" class="headerlink" title="图的邻接矩阵表示"></a>图的邻接矩阵表示</h3><p>邻接矩阵让每一个节点和一个整数相关联，该整数作为数组的下标值<br>用一个二维数组来表示顶点之间的连接<br><img src="./tu.png"><br>在这个二维数组中，0表示两顶点间没有连线，1表示有连线。另外顶点到自己的连线通常用0表示</p>
<p>邻接矩阵的问题：<br>如果一个图是稀疏图，那么用邻接矩阵表示这个图就会存在大量的0，浪费了计算机存储空间来保持不存在的边</p>
<h3 id="图的邻接表表示"><a href="#图的邻接表表示" class="headerlink" title="图的邻接表表示"></a>图的邻接表表示</h3><p>邻接表是由图中每个顶点以及和顶点相邻的顶点列表组成。<br>这个与顶点相邻的顶点列表可以使用数组、链表或者哈希表。<br><img src="./tu2.png"></p>
<p>对于有向图，顶点存储的是从它指出去的顶点，一个顶点指向别人的数量叫做<strong>出度</strong>，别人指向这个顶点的数量叫做<strong>入度</strong><br>邻接表计算出度十分的方便，如果要计算入度，那么构建一个<strong>逆邻接矩阵</strong>会效率更高</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>对无向图进行代码实现，并且用数组来存放顶点和边</p>
<p><strong>添加顶点和边</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//存放顶点的数组</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vertexes</span> = []</span><br><span class="line">    <span class="comment">//用map来存储顶点及其对应顶点（边）</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">edges</span> = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//添加顶点</span></span><br><span class="line">  <span class="title function_">addVertex</span>(<span class="params">v</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vertexes</span>.<span class="title function_">push</span>(v)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">edges</span>.<span class="title function_">set</span>(v, [])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//添加边</span></span><br><span class="line">  <span class="title function_">addEdge</span>(<span class="params">v1, v2</span>) &#123;</span><br><span class="line">    <span class="comment">//判断顶点是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">findVertex</span>(v1) &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">findVertex</span>(v2)) &#123;</span><br><span class="line">      <span class="comment">//this.edges.get(v1)可以得到v1对应的相邻顶点列表，将相邻顶点存放在这个顶点列表中</span></span><br><span class="line">      <span class="comment">//无向图</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">edges</span>.<span class="title function_">get</span>(v1).<span class="title function_">push</span>(v2)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">edges</span>.<span class="title function_">get</span>(v2).<span class="title function_">push</span>(v1)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//判断顶点是否存在</span></span><br><span class="line">  <span class="title function_">findVertex</span>(<span class="params">v</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">vertexes</span>.<span class="property">length</span>; i++ )&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">vertexes</span>[i] == v) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>打印图</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">vertexes</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    res += val + <span class="string">&#x27;: &#x27;</span> + <span class="variable language_">this</span>.<span class="property">edges</span>.<span class="title function_">get</span>(val).<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>) + <span class="string">&#x27;\n&#x27;</span> </span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果样式如下</span></span><br><span class="line"><span class="comment">//A: B C</span></span><br><span class="line"><span class="comment">//B: A C</span></span><br><span class="line"><span class="comment">//C: A B D</span></span><br><span class="line"><span class="comment">//D: C</span></span><br></pre></td></tr></table></figure>

<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>图的遍历是图的一个重要部分。<br>图的遍历意味着要将图中的每个顶点访问一边，并且不能重复访问</p>
<p>图遍历的两种算法：</p>
<ol>
<li>广度优先搜索（Breadth-First Search, BFS）</li>
<li>深度优先搜索（Depth-First Search, DFS）</li>
</ol>
<p>顶点的状态：在遍历中我们为顶点定义了3中状态</p>
<ol>
<li>状态0：表示未被访问</li>
<li>状态1：表示被访问到了</li>
<li>状态2：表示它的相邻顶点也被访问了（即这个顶点的完全访问状态）<h4 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h4>思路：先从指定的第一个顶点开始，访问它的所有相邻顶点，就像一次访问图的一层。</li>
</ol>
<p>实现：创建一个队列来实现BFS，从指定的第一个顶点开始，将这个顶点状态设为1，并添加到队列中。然后依次访问它的所有未被访问的相邻顶点，并将它们添加到队列。这个顶点出队，状态设为2</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为每个顶点设置初始状态0</span></span><br><span class="line"><span class="title function_">initState</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> state = []</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">vertexes</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    state[val] = <span class="number">0</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> state</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * initV：从这个顶点开始搜索</span></span><br><span class="line"><span class="comment"> * handler：函数，自定义打印结果的方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">bfs</span>(<span class="params">initV, handler</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> state = <span class="variable language_">this</span>.<span class="title function_">initState</span>()</span><br><span class="line">  <span class="comment">//创建队列，这里用数组简陋替代</span></span><br><span class="line">  <span class="keyword">let</span> queue = []</span><br><span class="line">  <span class="comment">//将第一个顶点添加到队列，并将他状态设置为1</span></span><br><span class="line">  queue.<span class="title function_">push</span>(initV)</span><br><span class="line">  state[initV] = <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(queue.<span class="property">length</span> != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//移除队头顶点，将他状态设置为2</span></span><br><span class="line">    <span class="keyword">let</span> v = queue.<span class="title function_">shift</span>()</span><br><span class="line">    state[v] = <span class="number">2</span></span><br><span class="line">    <span class="comment">//得到移除的队头顶点的相邻顶点列表</span></span><br><span class="line">    <span class="keyword">let</span> vList = <span class="variable language_">this</span>.<span class="property">edges</span>.<span class="title function_">get</span>(v)</span><br><span class="line">    <span class="comment">//将相邻顶点添加到队列中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;vList.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> e = vList[i]</span><br><span class="line">      <span class="comment">//只添加为被访问的相邻顶点（因为有可能这个顶点在前一次被访问了，但是它还没有出队）</span></span><br><span class="line">      <span class="keyword">if</span>(state[e] == <span class="number">0</span>) &#123;</span><br><span class="line">        queue.<span class="title function_">push</span>(e)</span><br><span class="line">        state[e] = <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印结果</span></span><br><span class="line">    <span class="title function_">handler</span>(v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h4><p>思路：从第一个指定顶点开始，沿着一条路径访问到最深处（访问不下去了），然后回退到上一个顶点，如果上一个顶点有其他未访问的相邻顶点，就访问其他相邻顶点；如果没有未访问的相邻顶点，就再回退到上一个顶点，重复以上步骤</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">dfs</span>(<span class="params">initV, handler</span>) &#123;</span><br><span class="line">  <span class="comment">//设置初始状态0</span></span><br><span class="line">  <span class="keyword">let</span> state = <span class="variable language_">this</span>.<span class="title function_">initState</span>()</span><br><span class="line">  <span class="comment">//调用dfsVisit函数实现dfs</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">dfsVisit</span>(initV, state, handler)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * v：起始顶点</span></span><br><span class="line"><span class="comment"> * state：顶点的状态数组</span></span><br><span class="line"><span class="comment"> * handler：函数，自定义结果打印方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">dfsVisit</span>(<span class="params">v, state, handler</span>) &#123;</span><br><span class="line">  state[v] = <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> vList = <span class="variable language_">this</span>.<span class="property">edges</span>.<span class="title function_">get</span>(v)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handler</span>(v)</span><br><span class="line">  state[v] = <span class="number">2</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;vList.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> e = vList[i]</span><br><span class="line">    <span class="keyword">if</span>(state[e] == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">dfsVisit</span>(e, state, handler)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小c只会突破</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://kyriecqy.github.io/2022/06/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">https://kyriecqy.github.io/2022/06/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://kyriecqy.github.io" target="_blank">kyrie C</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="/images/logo.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/06/11/%E7%8E%B0%E4%BB%A3JavaScript/"><img class="next-cover" src="/images/logo.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">现代JavaScript</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/irving.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">小c只会突破</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/kyriecqy"><i class="fab fa-github"></i><span>前往Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/kyriecqy" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">我始终认为男人的体格和力气是用来保护女性的</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">1.1.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">1.2.</span> <span class="toc-text">队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">1.3.</span> <span class="toc-text">单向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">1.4.</span> <span class="toc-text">双向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.5.</span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%8C%96%E6%95%88%E7%8E%87"><span class="toc-number">1.5.1.</span> <span class="toc-text">哈希化效率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E4%B9%A6%E5%86%99"><span class="toc-number">1.5.2.</span> <span class="toc-text">哈希函数书写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.5.3.</span> <span class="toc-text">实现哈希表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%89%A9%E5%AE%B9"><span class="toc-number">1.5.4.</span> <span class="toc-text">哈希表的扩容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E5%93%88%E5%B8%8C%E8%A1%A8%E4%BB%A3%E7%A0%81"><span class="toc-number">1.5.5.</span> <span class="toc-text">完整哈希表代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">1.6.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.6.1.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">二叉搜索树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">红黑树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">红黑树的插入</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">1.7.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.7.1.</span> <span class="toc-text">图的邻接矩阵表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.7.2.</span> <span class="toc-text">图的邻接表表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.3.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.7.4.</span> <span class="toc-text">图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88BFS%EF%BC%89"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">广度优先搜索（BFS）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88DFS%EF%BC%89"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">深度优先搜索（DFS）</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/06/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构"><img src="/images/logo.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构"/></a><div class="content"><a class="title" href="/2022/06/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构">数据结构</a><time datetime="2022-06-22T02:36:28.000Z" title="发表于 2022-06-22 10:36:28">2022-06-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/11/%E7%8E%B0%E4%BB%A3JavaScript/" title="现代JavaScript"><img src="/images/logo.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="现代JavaScript"/></a><div class="content"><a class="title" href="/2022/06/11/%E7%8E%B0%E4%BB%A3JavaScript/" title="现代JavaScript">现代JavaScript</a><time datetime="2022-06-11T06:14:38.000Z" title="发表于 2022-06-11 14:14:38">2022-06-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/05/TypeScript/" title="TypeScript"><img src="/images/logo.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TypeScript"/></a><div class="content"><a class="title" href="/2022/06/05/TypeScript/" title="TypeScript">TypeScript</a><time datetime="2022-06-05T12:23:59.000Z" title="发表于 2022-06-05 20:23:59">2022-06-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/04/Webpack%E5%8E%9F%E7%90%86/" title="Webpack原理"><img src="/images/logo.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Webpack原理"/></a><div class="content"><a class="title" href="/2022/06/04/Webpack%E5%8E%9F%E7%90%86/" title="Webpack原理">Webpack原理</a><time datetime="2022-06-04T10:30:30.000Z" title="发表于 2022-06-04 18:30:30">2022-06-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/04/Webpack%E9%85%8D%E7%BD%AEVue-cli/" title="Webpack配置Vue-cli"><img src="/images/logo.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Webpack配置Vue-cli"/></a><div class="content"><a class="title" href="/2022/06/04/Webpack%E9%85%8D%E7%BD%AEVue-cli/" title="Webpack配置Vue-cli">Webpack配置Vue-cli</a><time datetime="2022-06-04T02:34:22.000Z" title="发表于 2022-06-04 10:34:22">2022-06-04</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/images/bg5.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 By 小c只会突破</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>