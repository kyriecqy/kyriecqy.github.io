<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JS高级（2） | kyrie C</title><meta name="keywords" content="JS 基础语言"><meta name="author" content="小c只会突破"><meta name="copyright" content="小c只会突破"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Level 2JSONJSON是Javascript的严格子集。可以将它当作是一种数据格式 语法JSON语法接受3种类型的值：  简单值： 字符串、数值、布尔值和null（undefine都不可以使用） 对象：复杂类型。有序的键值对，每个值可以是简单值，也可以是复杂类型 数组：复杂类型。有序的列表，数组的值可以任意  JSON没有变量，函数的概念 简单值 例如下面的有效JSON： 1&quot;h">
<meta property="og:type" content="article">
<meta property="og:title" content="JS高级（2）">
<meta property="og:url" content="https://kyriecqy.github.io/2022/05/22/JS%E9%AB%98%E7%BA%A7(2)/index.html">
<meta property="og:site_name" content="kyrie C">
<meta property="og:description" content="Level 2JSONJSON是Javascript的严格子集。可以将它当作是一种数据格式 语法JSON语法接受3种类型的值：  简单值： 字符串、数值、布尔值和null（undefine都不可以使用） 对象：复杂类型。有序的键值对，每个值可以是简单值，也可以是复杂类型 数组：复杂类型。有序的列表，数组的值可以任意  JSON没有变量，函数的概念 简单值 例如下面的有效JSON： 1&quot;h">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kyriecqy.github.io/images/logo.jpg">
<meta property="article:published_time" content="2022-05-22T06:22:31.000Z">
<meta property="article:modified_time" content="2022-06-03T01:17:02.423Z">
<meta property="article:author" content="小c只会突破">
<meta property="article:tag" content="JS 基础语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kyriecqy.github.io/images/logo.jpg"><link rel="shortcut icon" href="/images/logo.jpg"><link rel="canonical" href="https://kyriecqy.github.io/2022/05/22/JS%E9%AB%98%E7%BA%A7(2)/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JS高级（2）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-03 09:17:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/irving.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/bg3.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">kyrie C</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JS高级（2）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-22T06:22:31.000Z" title="发表于 2022-05-22 14:22:31">2022-05-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-03T01:17:02.423Z" title="更新于 2022-06-03 09:17:02">2022-06-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Learn%E6%96%87%E6%A1%A3/">Learn文档</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JS高级（2）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Level-2"><a href="#Level-2" class="headerlink" title="Level 2"></a>Level 2</h1><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON是Javascript的严格子集。可以将它当作是一种数据格式</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>JSON语法接受3种类型的值：</p>
<ol>
<li>简单值： 字符串、数值、布尔值和null（undefine都不可以使用）</li>
<li>对象：复杂类型。有序的键值对，每个值可以是简单值，也可以是复杂类型</li>
<li>数组：复杂类型。有序的列表，数组的值可以任意</li>
</ol>
<p>JSON没有变量，函数的概念</p>
<p><strong>简单值</strong></p>
<p>例如下面的有效JSON：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
<p>JS字符串和JSON字符串的主要区别是，JSON字符串一定要用<strong>双引号</strong></p>
<p><strong>对象</strong></p>
<p>例如下面的有效JSON：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;cqy&quot;</span>,</span><br><span class="line">  <span class="string">&quot;sex&quot;</span>: <span class="string">&quot;man&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与JS不同的是，JSON对象中的属性名和属性值都要用<strong>双引号</strong>，因为JSON中没有变量，所以也不用向JS那样进行变量声明</p>
<p><strong>数组</strong></p>
<p>例如下面的有效JSON：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">11</span>, <span class="string">&quot;kyrie&quot;</span>, <span class="literal">true</span>]</span><br></pre></td></tr></table></figure>
<p>同样的不用变量声明，可以使用任意数据类型</p>
<h3 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a>JSON对象</h3><p>ES5新增JSON全局对象，正式引入解析JSON的能力</p>
<p>JSON对象有两个方法：<code>stringify()</code>和<code>parse()</code>，这两种方法分别可以将JS序列化为JSON对象，以及 将JSON对象解析为JS</p>
<p>来看下面的例子：下面的代码中使用stringify方法将JS对象序列化为JSON对象，<code>JSON.stringify()</code>会返回不包含空格和缩进的JSON字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kyrie&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">29</span>,</span><br><span class="line">  <span class="attr">sex</span>: <span class="string">&#x27;man&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> json_p = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(p)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(json_p); <span class="comment">//&#123;&quot;name&quot;:&quot;kyrie&quot;,&quot;age&quot;:29,&quot;sex&quot;:&quot;man&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>在序列化过程中，所以函数、原型对象以及undefined都会被忽略，只返回合法的JSON数据类型</p>
<p>使用<code>JSON.parse()</code>可以将JSON解析为JS</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parse_p = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(json_p)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(parse_p); <span class="comment">// &#123; name: &#x27;kyrie&#x27;, age: 29, sex: &#x27;man&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="序列化选项"><a href="#序列化选项" class="headerlink" title="序列化选项"></a>序列化选项</h4><p>使用<code>JSON.stringify()</code>序列化一个JS对象时，还可以传入第二个、第三个参数。<br>传入的第二个参数是过滤器，可以是数组或函数</p>
<ol>
<li>第二个参数是数组时，<code>JSON.stringify()</code>返回的结果中只会包含数组中的属性名<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kyrie&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">29</span>,</span><br><span class="line">  <span class="attr">sex</span>: <span class="string">&#x27;man&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> json_p = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(p, [<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(json_p); <span class="comment">// &#123;&quot;name&quot;:&quot;kyrie&quot;&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>第二个参数时函数时，这个函数有两个参数：属性名（key）和 属性值（value）。可以根据key对相应属性进行操作，返回操作后的结果。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> json_p = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(p, <span class="keyword">function</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(key == <span class="string">&#x27;name&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;harden&#x27;</span></span><br><span class="line">  <span class="comment">//注意：除了对需要的数据进行操作，还要记得返回其他属性</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> value</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(json_p);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>传入的第三个参数用于设置结果的缩进</p>
<ol>
<li>当第三个参数是数值时，每一次会按照这个数值来缩进对应空格数（最大为10，超过了一律变为10）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> json_p = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(p, <span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(json_p); </span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//  &quot;name&quot;: &quot;kyrie&quot;,</span></span><br><span class="line"><span class="comment">//  &quot;age&quot;: 29,</span></span><br><span class="line"><span class="comment">//  &quot;sex&quot;: &quot;man&quot;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>当第三个参数是字符串时，会使用这个字符串来缩进（最大长度也是10）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> json_p = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(p, <span class="literal">null</span>, <span class="string">&#x27;+++++&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(json_p);</span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//+++++&quot;name&quot;: &quot;kyrie&quot;,</span></span><br><span class="line"><span class="comment">//+++++&quot;age&quot;: 29,</span></span><br><span class="line"><span class="comment">//+++++&quot;sex&quot;: &quot;man&quot;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="解析选项"><a href="#解析选项" class="headerlink" title="解析选项"></a>解析选项</h4></li>
</ol>
<p><code>JSON.parse()</code>也可以接收第二个参数，这个参数是函数，这个函数会针对每一个键值对都调用一次。同样的，这个函数也有两个参数：属性名（key）和 属性值（value）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> json_p = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(p)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> parse_p = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(json_p, <span class="keyword">function</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> key == <span class="string">&#x27;sex&#x27;</span> ? <span class="string">&#x27;男&#x27;</span> : value</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(parse_p); <span class="comment">//&#123; name: &#x27;kyrie&#x27;, age: 29, sex: &#x27;男&#x27; &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="执行上下文和作用域"><a href="#执行上下文和作用域" class="headerlink" title="执行上下文和作用域"></a>执行上下文和作用域</h2><p>执行上下文在JS中十分重要，变量或函数的上下文决定了它可以访问哪些数据。每个上下文都有一个关联的<strong>变量对象</strong>，它包含了这个上下文中所有的变量和函数</p>
<p>全局上下文是最外层的上下文。在浏览器中，全局上下文是window对象，使用var定义的变量或函数（let和const定义的不会）会变成window的属性和方法</p>
<p>上下文会在执行完它的所有代码之后被销毁，包括定义在它上面的变量和函数</p>
<p>每个函数调用时都会有上下文，当执行函数时，函数上下文被推入一个上下文栈；函数执行完成时，函数上下文会被弹栈</p>
<p>上下文中的代码在执行时，会创建变量的<strong>作用域链</strong>，它觉得了各级上下文访问属性和方法时的顺序</p>
<p>正在执行的代码所在的上下文变量对象处于作用域链的最顶端。如果上下文是函数，那么它的 <strong>活动对象（最初只有一个变量：arguments）</strong> 作为变量对象。<br>作用域链的下一个对象是 <strong>包含该上下文的上下文的变量对象</strong>，以此类推到全局上下文，全局上下文的变量对象始终处于作用域链的最后。代码执行时解析标识符是通过作用域链逐级向下寻找</p>
<p>对下面的例子来说，函数fn的作用域链包含两个对象。一个是它自己的变量对象，另一个是全局上下文的变量对象。当执行函数时，在它的变量对象中没有找到p属性，然后沿着作用域链来到全局变量对象，在它上面找到了p属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="string">&#x27;cqy&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="title function_">fn</span>() <span class="comment">//cqy</span></span><br></pre></td></tr></table></figure>

<p>来看一个更复杂的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="string">&#x27;cqy&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sex = <span class="string">&#x27;man&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> age = <span class="number">29</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以访问p，sex，age</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(sex);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">fn2</span>() </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以访问sex，p，不可以访问age</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(age); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只能访问p</span></span><br><span class="line"><span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure>
<p>上面的代码涉及三个上下文：全局上下文，函数fn上下文，函数fn2上下文。<br><img src="./%E4%BD%9C%E7%94%A8%E5%9F%9F.png" alt="pic"></p>
<p>内部上下文可以通过作用域链访问外部上下文的一切，外部上下文无法访问内部上下文</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><ol>
<li><p><strong>var</strong><br>使用var声明变量，变量会被添加到最接近的上下文。如果变量未经声明就初始化了，会被添加到全局上下文（未声明就初始化是一个错误行为）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;kyrie&#x27;</span></span><br><span class="line">  age = <span class="number">29</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">//报错，name在函数外部无法访问</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 29，age未声明就初始化，被添加到全局上下文</span></span><br></pre></td></tr></table></figure>
<p>var声明会被拿到函数或全局作用域的顶部，位于所有代码之前，这种现象叫做”提升”。这就会导致一个合法却奇怪的现象，即在声明变量之前使用变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">//cqy</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;cqy&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>let</strong><br>let的作用域是块级的，块级作用域就是由最近的一对<code>&#123;&#125;</code>界定</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">//报错，a没有定义</span></span><br></pre></td></tr></table></figure>
<p>let与var的不同之处在于，let不能在同一个作用域内重复声明，而重复声明var会被忽略</p>
</li>
<li><p><strong>const</strong><br>const在声明时必须同时初始化，并在其生命周期内不能被赋其他值<br>const声明只应用到顶级原语或对象，也就是说，赋值为对象的const不能被赋值为其他引用值，但他的键则不受影响</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p =&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kyrie&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p = &#123;&#125; <span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line">p.<span class="property">name</span> = <span class="string">&#x27;harden&#x27;</span> <span class="comment">//合法</span></span><br></pre></td></tr></table></figure>
<p>如果想让整个对象都不能修改那就使用<code>Object.freeze()</code>方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">p.<span class="property">name</span> = <span class="string">&#x27;haha&#x27;</span> <span class="comment">//报错</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象的创建最常见的有两种方法：使用<code>new</code>关键字 和 对象字面量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用new关键字</span></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">person.<span class="property">name</span> = <span class="string">&#x27;kyrie&#x27;</span></span><br><span class="line">person.<span class="property">say</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字面量形式</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;harden&#x27;</span>,</span><br><span class="line">  <span class="title function_">say</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="属性的类型"><a href="#属性的类型" class="headerlink" title="属性的类型"></a>属性的类型</h3><p>ECMA-262定义了一些内部特征来描述属性的类型，不能直接在JS中访问这些类型。为了将某个特性标识为内部特性，一般用两个中括号包裹。<br>属性类型分为两种：数据属性，访问器属性</p>
<h4 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h4><p>数据属性会包含一个数据值的位置，写入数据和读取是数据都在这里进行，有四个特性来描述他的行为</p>
<ol>
<li><code>[[Configurable]]</code>：表示属性是否可以用delete删除再定义、是否可以修改他的特性和访问器属性。默认为true</li>
<li><code>[[Enumberable]]</code>：表示属性是否可以被枚举（for in等循环），默认为true</li>
<li><code>[[Writable]]</code>：表示属性值是否可以被修改，默认为true</li>
<li><code>[[Value]]</code>：属性的实际值，默认undefined</li>
</ol>
<p>要修改属性的特性，必须使用<code>Object.defineProperty()</code>方法，他接收三个参数：要操作的对象，属性的名称 和 描述符对象（就是包含上述特性的对象）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;kyrie&#x27;</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">//&#123; name: &#x27;kyrie&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line">person.<span class="property">name</span> = <span class="string">&#x27;harden&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">//&#123; name: &#x27;kyrie&#x27; &#125; writable为false表示属性不可以被修改</span></span><br></pre></td></tr></table></figure>

<p>当configurable为false时，这个属性无法被删除，严格模式下会报错。<br>并且也不允许再调用一次defineProperty来修改特性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;kyrie&#x27;</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">//kyrie</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person.<span class="property">name</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">//kyrie</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&#x27;name&#x27;</span>, &#123; <span class="comment">//报错</span></span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;kyrie&#x27;</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h4><p>访问器属性不包含数据值，它包含一个获取函数（getter）和一个设置函数（setter）。在读取数据值时会调用获取函数，返回数据值；写入数据时会调用设置函数。有四个特性描述它们的行为：</p>
<ol>
<li><code>[[configurable]]</code></li>
<li><code>[[enumerable]]</code></li>
<li><code>[[Get]]</code>：获取函数，默认undefined</li>
<li><code>[[Set]]</code>：设置函数，默认undefined<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name_</span>: <span class="string">&#x27;kyrie&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get函数被调用&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name_</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set函数被调用&#x27;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name_</span> = newValue</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); </span><br><span class="line"></span><br><span class="line">person.<span class="property">name</span> = <span class="string">&#x27;harden&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img src="./%E5%AF%B9%E8%B1%A1.png" alt="pic"></li>
</ol>
<h4 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h4><p>使用<code>Object.getOwnPropertyDescriptor()</code>方法可以取得指定属性的属性描述符，它接收两个参数：属性所在对象 和 要获取描述符的属性名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name_</span>: <span class="string">&#x27;kyrie&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get函数被调用&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name_</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set函数被调用&#x27;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name_</span> = newValue</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> describer = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(person, <span class="string">&#x27;name_&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(describer);</span><br></pre></td></tr></table></figure>
<p><img src="./%E5%AF%B9%E8%B1%A12.png" alt="pic"></p>
<h3 id="合并对象"><a href="#合并对象" class="headerlink" title="合并对象"></a>合并对象</h3><p>将一个或多个对象的属性合并到一个目标对象上，也被叫做“混入（mixin）”</p>
<p>ES6提供了合并对象的方法<code>Object.assign()</code>，这个方法接收一个目标对象，以及一个或多个源对象。将每个源对象中<strong>可枚举（ Object.propertyIsEnumerable() ）</strong>和<strong>自有的属性（ Object.hasOwnProperty() ）</strong>复制到目标对象上。<br>这个方法还会使用源对象上的<code>[[Get]]</code>取得属性的值，然后使用目标对象的<code>[[Set]]</code>设置属性值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o1, o2</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    简单赋值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">o1 = &#123;&#125;</span><br><span class="line">o2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kyrie&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(o1, o2)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o1); <span class="comment">//&#123; name: &#x27;kyrie&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    多个源对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">o1 = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(o1, &#123; <span class="attr">name</span>: <span class="string">&#x27;harden&#x27;</span> &#125;, &#123; <span class="attr">age</span>: <span class="number">32</span> &#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o1); <span class="comment">//&#123; name: &#x27;harden&#x27;, age: 32 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取函数和设置函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> o1, o2</span><br><span class="line"></span><br><span class="line">o1 = &#123;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">a</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o2 = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">a</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是get&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;哈哈&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(o1,o2) <span class="comment">//这里的设置函数没有执行赋值操作，其实并没有把值转移过来</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o1.<span class="property">a</span>);</span><br><span class="line"><span class="comment">//我是get</span></span><br><span class="line"><span class="comment">//哈哈</span></span><br><span class="line"><span class="comment">//undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Object..assign()其实是对每个源对象进行浅复制。如果多个源对象有相同的属性，那么将使用最后复制的属性值</p>
<h3 id="增强对象语法"><a href="#增强对象语法" class="headerlink" title="增强对象语法"></a>增强对象语法</h3><p><strong>属性值简写</strong></p>
<p>给对象添加变量，当属性与变量相同时，可以只写变量名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;cqy&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//属性值简写</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可计算属性</strong></p>
<p>在没有可计算属性之前，如果要使用变量作为属性名，需要先创建变量，再使用中括号语法添加，也就是说不可以动态赋值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nameKey = <span class="string">&#x27;name&#x27;</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;&#125;</span><br><span class="line">person[nameKey] = <span class="string">&#x27;cqy&#x27;</span></span><br></pre></td></tr></table></figure>
<p>可计算属性就是使用中括号包裹变量作为对象的属性名（会将中括号中的内容当作JS表达式来求值），可以动态进行添加</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nameKey = <span class="string">&#x27;name&#x27;</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  [nameKey]: <span class="string">&#x27;cqy&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><p>对象解构就是使用与对象匹配的结构来实现对象属性赋值<br>下面是不使用对象解构的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kyrie&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">29</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pName = person.<span class="property">name</span></span><br></pre></td></tr></table></figure>
<p>然后，是使用对象解构的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kyrie&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">29</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; name, age &#125; = person</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name) <span class="comment">//kyrie</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age) <span class="comment">//29</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用解构，可以在一个类似对象字面量的结构中声明多个变量并进行赋值操作。如果想让变量直接使用属性的名称，那么就按照上面的简写写法。</p>
<p>如果引用的属性在对象中不存在，那么变量的值为undefined。也可以对解构的变量赋初始值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kyrie&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">29</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; name, sex=<span class="string">&quot;man&quot;</span> &#125; = person</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sex) <span class="comment">//man</span></span><br></pre></td></tr></table></figure>
<p>如果要将解构出来的变量赋值给其他事先声明的变量，解构表达式要包括在一个括号内</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kyrie&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">29</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> n, a</span><br><span class="line"><span class="comment">//使用括号包裹</span></span><br><span class="line">(&#123; <span class="attr">name</span>: n, <span class="attr">age</span>: a &#125; = person)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n, a) <span class="comment">//kyrie 29</span></span><br></pre></td></tr></table></figure>
<h4 id="嵌套解构"><a href="#嵌套解构" class="headerlink" title="嵌套解构"></a>嵌套解构</h4><p>解构对引用嵌套的属性或赋值目标没有限制</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kyrie&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">29</span>,</span><br><span class="line">  <span class="attr">job</span>: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;basketball player&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">(&#123; <span class="attr">name</span>: p.<span class="property">name</span>, <span class="attr">age</span>: p.<span class="property">age</span>, <span class="attr">job</span>: p.<span class="property">job</span>&#125; = person)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p); <span class="comment">//&#123; name: &#x27;kyrie&#x27;, age: 29, job: &#123; title: &#x27;basketball player&#x27; &#125; &#125;</span></span><br><span class="line"></span><br><span class="line">person.<span class="property">job</span>.<span class="property">title</span> = <span class="string">&#x27;MVP&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">job</span>.<span class="property">title</span>); <span class="comment">//MVP</span></span><br><span class="line"><span class="comment">//将job对象的引用赋值给了p对象，所以person.job的更新也会影响p</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>用于直接取得嵌套内部的属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kyrie&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">29</span>,</span><br><span class="line">  <span class="attr">job</span>: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;basketball player&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">job</span>: &#123; title &#125; &#125; = person</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(title); <span class="comment">//basketball player</span></span><br></pre></td></tr></table></figure>

<h4 id="函数参数匹配"><a href="#函数参数匹配" class="headerlink" title="函数参数匹配"></a>函数参数匹配</h4><p>解构也可用于给函数参数列表，而且不会影响arguments对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kyrie&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">29</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">&#123;name, age&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name, age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(person)</span><br><span class="line"><span class="comment">//[Arguments] &#123; &#x27;0&#x27;: &#123; name: &#x27;kyrie&#x27;, age: 29 &#125; &#125;</span></span><br><span class="line"><span class="comment">//kyrie 29</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>虽然Object的构造函数方法与字面量方法创建对象很方便，但是当需要大量创建有相同接口的对象时就要重复写许多代码</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式就是用抽象创建特定对象的过程</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> createPerson = <span class="keyword">function</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> o = &#123;&#125;</span><br><span class="line">  o.<span class="property">name</span> = name</span><br><span class="line">  o.<span class="property">age</span> = age</span><br><span class="line">  <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title function_">createPerson</span>(<span class="string">&#x27;cqy&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1); <span class="comment">//&#123; name: &#x27;cqy&#x27;, age: 20 &#125;</span></span><br></pre></td></tr></table></figure>
<p>工厂模式可以实现创建多个类似对象的问题，但没有解决对象标识问题（新对象是什么类型）</p>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>ECMA中的构造函数是用于创建特定类型对象的，类似于Object和Array使用new关键字调用构造函数。<br>当然也可以自定义构造函数，以函数的形式为自定义对象类型定义属性和方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照惯例，构造函数名称的首字母要大写</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">print</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name, age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;kyrie&#x27;</span>, <span class="number">29</span>)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">print</span>() <span class="comment">//kyrie 29</span></span><br></pre></td></tr></table></figure>
<p>使用构造函数代替工厂函数，构造函数注意有以下区别：</p>
<ol>
<li>没有显式的创建对象</li>
<li>属性和方法都直接赋值给this</li>
<li>没有 return</li>
</ol>
<p>在使用new关键字创建Person实例时，构造函数执行了以下操作：</p>
<ol>
<li>在内存创建一个对象，这个对象的<code>[[Prototype]]</code> 被赋值为构造函数的prototype属性</li>
<li>构造函数中的this指向新对象</li>
<li>完成构造函数内部代码，返回对象</li>
</ol>
<p>用构造函数的方式创建出来的每个对象都是Object的实例，也是Person的实例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p <span class="keyword">instanceof</span> <span class="title class_">Object</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p <span class="keyword">instanceof</span> <span class="title class_">Person</span>);</span><br></pre></td></tr></table></figure>
<p>构造函数也存在一定的问题，在下面的例子中，两个print()函数虽然是同名函数，但它们却不相同。我们知道函数其实也是个对象，所以在每次定义函数时，都相当于初始化了一个函数对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">print</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name, age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;kyrie&#x27;</span>, <span class="number">29</span>)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;harden&#x27;</span>, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">print</span> == p2.<span class="property">print</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>做的都是同一件事，没必要创建多个不同的函数对象。这个问题可以通过原型模式来解决</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>每个函数都会创建一个<code>prototype</code>属性，它是一个对象，包含可以在特定引用类型的实例中共享的属性和方法。这个对象就是调用构造函数创建的对象的原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;kyrie&quot;</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">print</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line">p1.<span class="title function_">print</span>() <span class="comment">//kyrie</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line">p2.<span class="title function_">print</span>() <span class="comment">//kyrie</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">print</span> == p2.<span class="property">print</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中的属性和方法都被定义在了Person的prototype属性上，可以在Person的所有实例间共享。因此p1和p2访问的属性和方法都是同样的。</p>
<h4 id="理解原型"><a href="#理解原型" class="headerlink" title="理解原型"></a>理解原型</h4><p>只要创建一个函数，就会给函数创建一个prototype属性，它指向原型对象。默认情况下，原型对象自动获得一个<code>constructor</code>属性，这个属性指回与之相关联的构造函数。<br>按前面的例子来说：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Person</span></span><br></pre></td></tr></table></figure>
<p>在自定义构造函数时，原型对象默认只有constructor属性，其他所有的方法都继承自Object。</p>
<p>每次调用构造函数创建实例，实例内部的<code>[[Prototype]]</code>属性会指向原型对象。可以使用<code>__proto__</code>属性来访问实例对象的原型对象。</p>
<p><strong>理解关键的一点：实例与原型对象有直接关系，构造函数与原型对象有直接关系，但是实例与构造函数没有直接关系</strong></p>
<p>通过下来的代码来理解以下原型的行为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 声明之后，构造函数就有一个与之关联的原型对象</span></span><br><span class="line"><span class="comment">* 构造函数通过prototype属性链接原型对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//  constructor: f Person(),</span></span><br><span class="line"><span class="comment">//  __proto__: Object</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 原型对象的constructor属性指回与之关联的构造函数</span></span><br><span class="line"><span class="comment">* 两者循环引用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> == <span class="title class_">Person</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 正常的原型链都终止于Object的原型对象</span></span><br><span class="line"><span class="comment">* Object的原型的原型是null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>.<span class="property">constructor</span> === <span class="title class_">Object</span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>.<span class="property">__proto__</span> === <span class="literal">null</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 实例通过__proto__属性访问原型对象</span></span><br><span class="line"><span class="comment">* 实例与构造函数没有直接联系</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">__proto__</span>.<span class="property">constructor</span> === <span class="title class_">Person</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 同一个构造函数的实例共享同一个原型对象</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">__proto__</span> === p2.<span class="property">__proto__</span>); <span class="comment">//true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下图是Person构造函数，Person原型对象和两个Person实例之间的关系<br><img src="./%E5%8E%9F%E5%9E%8B%E9%93%BE.png"></p>
<p>并不是所有实例都暴露了<code>[[Prototype]]</code>属性，但可以通过原型对象调用<code>isPrototypeOf()</code>方法来确定两者之间的关系</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(p1)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>Object类型有一个方法<code>Object.getPrototypeOf()</code>，可以返回参数的内部<code>[[Prototype]]</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(p1) === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>Object类型还有一个<code>setPrototypeOf()</code>方法，它可以向实例的<code>[[Prototype]]</code>写入一个新值，可以重写对象的原型继承关系</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kyrie&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myProto = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">29</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(person, myProto)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">age</span>); <span class="comment">//29</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">__proto__</span> === myProto); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="原型层级"><a href="#原型层级" class="headerlink" title="原型层级"></a>原型层级</h4><p>在通过对象访问属性是时，搜索开始于实例本身。<br>先在实例上查找有没有这个属性，如果找到了就返回属性的值，并停止搜索。<br>如果在实例上没找到，会沿着指针进入原型对象，在原型对象上进行查找。如果在原型上找到了属性就返回属性值。<br>这就是原型在多个实例间共享属性和方法的原理</p>
<p>虽然可以读取原型上的属性，但是无法通过实例重写原型上的值。如果在实例上创建与原型中同名的属性，那么这个属性就会遮住原型对象上的属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;kyrie&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line">p1.<span class="property">name</span> = <span class="string">&#x27;harden&#x27;</span> <span class="comment">//实例创建自己的name属性，会覆盖住原型中的name属性</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">name</span>); <span class="comment">//harden 来自实例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">name</span>); <span class="comment">//kyrie 来自原型</span></span><br></pre></td></tr></table></figure>
<p>只要给实例添加了原型中的同名属性，就会覆盖住原型中的同名属性。虽然不能修改原型属性，但会屏蔽对他的访问。即使将实例的同名属性设置为null，也不能消除屏蔽，需要使用delete删除实例上的同名属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;kyrie&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line">p1.<span class="property">name</span> = <span class="string">&#x27;harden&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">name</span>); <span class="comment">//harden</span></span><br><span class="line"></span><br><span class="line">p1.<span class="property">name</span> = <span class="literal">null</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">name</span>); <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> p1.<span class="property">name</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">name</span>); <span class="comment">//kyrie 来自原型</span></span><br></pre></td></tr></table></figure>

<p><strong>hasOwnProperty()</strong><br><code>hasOwnProperty()</code>方法用于确定某个属性是在实例上的还是在原型对象上的，当属性是在实例上时返回true。这个方法继承自Object。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;kyrie&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line">p1.<span class="property">name</span> = <span class="string">&#x27;harden&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> p1.<span class="property">name</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">//false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="原型与-in-操作符"><a href="#原型与-in-操作符" class="headerlink" title="原型与 in 操作符"></a>原型与 in 操作符</h4><p>有两种方法可以使用in操作符；单独使用 和 在for-in循环中使用</p>
<p><strong>单独使用</strong><br>在单独使用时，in操作符会在 可以在通过对象访问指定属性 时返回true，无论这个属性是在实例对象上还是在原型对象上</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;kyrie&#x27;</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> p1); <span class="comment">//来自原型</span></span><br><span class="line"></span><br><span class="line">p1.<span class="property">name</span> = <span class="string">&#x27;harden&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> p1); <span class="comment">//来自实例</span></span><br></pre></td></tr></table></figure>

<p>使用in操作符并结合<code>hasOwnProperty()</code>可以确定某个属性是否存在于原型上</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;kyrie&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义函数来判断属性是否存在于原型</span></span><br><span class="line"><span class="keyword">let</span> hasPrototypeProperty = <span class="keyword">function</span>(<span class="params">obj, pro</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (pro <span class="keyword">in</span> obj) &amp;&amp; !obj.<span class="title function_">hasOwnProperty</span>(pro)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hasPrototypeProperty</span>(p1, <span class="string">&#x27;name&#x27;</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">p1.<span class="property">name</span> = <span class="string">&#x27;cqy&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hasPrototypeProperty</span>(p1, <span class="string">&#x27;name&#x27;</span>)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p><strong>for-in循环中</strong></p>
<p>在for-in循环中使用in操作符，返回可以通过对象访问且可枚举的属性，无论是实例上的还是原型上的。遮盖了原型中不可枚举属性的实例属性也会被返回，因为默认开发者定义的属性都是可枚举的 </p>
<p>要获取实例上所有可枚举的属性，可以使用<code>Object.keys()</code>方法。这个方法接受一个对象作为参数，返回包含该对象所有可枚举属性名称的字符串数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;kyrie&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">p1.<span class="property">age</span> = <span class="number">29</span></span><br><span class="line">p1.<span class="property">print</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(p1)); <span class="comment">//[ &#x27;age&#x27;, &#x27;print&#x27; ]</span></span><br><span class="line"></span><br><span class="line">p1.<span class="property">name</span> = <span class="string">&#x27;cqy&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(p1)); <span class="comment">//[ &#x27;age&#x27;, &#x27;print&#x27;, &#x27;name&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p>要想列出所有实例属性（不管是否可枚举），可以使用<code>Object.getOwnPropertyNames()</code>方法</p>
<h3 id="对象迭代"><a href="#对象迭代" class="headerlink" title="对象迭代"></a>对象迭代</h3><p>两个静态方法<code>Object.values()</code>和<code>Object.entries()</code>接收一个对象，返回它们的内容数组。<code>Object.values()</code>返回对象值的数组，<code>Object.entries()</code>返回键值对的数组。<br>并且这两个方法都执行对象的浅复制</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kyrie&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">29</span>,</span><br><span class="line">  <span class="attr">sex</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="string">&#x27;A&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(o)); <span class="comment">//[ &#x27;kyrie&#x27;, 29, &#123; a: &#x27;A&#x27; &#125; ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(o)); <span class="comment">//[ [ &#x27;name&#x27;, &#x27;kyrie&#x27; ], [ &#x27;age&#x27;, 29 ], [ &#x27;sex&#x27;, &#123; a: &#x27;A&#x27; &#125; ] ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//浅复制</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(o)[<span class="number">2</span>] === o.<span class="property">sex</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h4 id="其他原型语法"><a href="#其他原型语法" class="headerlink" title="其他原型语法"></a>其他原型语法</h4><p>我们注意到，每次向原型上添加属性或方法都要书写<code>xx.prototype</code>，这就造成了代码的冗余。所以可以使用字面量的方法来重写原型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kyrie&#x27;</span>,</span><br><span class="line">  <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>Person.prototype</code>被设置成了一个通过字面量创建的对象，最终结果是一样的。</p>
<p><strong>但是这里会有一个问题：重写之后<code>Person.prototype.constructor</code>不再指向Person，而是指向Object构造函数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>); <span class="comment">// [Function: Object]</span></span><br></pre></td></tr></table></figure>

<p>因为在创建Person构造函数时，也会创建他的prototype对象，同时把这个constructor属性赋值。而上面的写法将默认的prototype重写，使constructor指向了Object对象。</p>
<p>当然我们可以在重写prototype时将constructor手动加进去。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">constructor</span>: <span class="title class_">Person</span>, <span class="comment">//将constructor的值设置为正确的值</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kyrie&#x27;</span>,</span><br><span class="line">  <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>); <span class="comment">// [Function: Person]</span></span><br></pre></td></tr></table></figure>
<p>但是以这种方式恢复的constructor是一个可枚举的属性，而constructor默认是不可枚举的。如果不希望它是一个可枚举属性，可以用<code>Object.defineProperty()</code>来定义</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kyrie&#x27;</span>,</span><br><span class="line">  <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;constructor&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="title class_">Person</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>);</span><br></pre></td></tr></table></figure>

<h4 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h4><p>在原型上搜索值是动态的，所以即使实例在修改原型之前已经存在，对原型的任何修改都会体现在实例上</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;kyrie&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>); <span class="comment">//kyrie 原型动态更新</span></span><br></pre></td></tr></table></figure>

<p>但是重写prototype之后就不是这么一回事了，实例的<code>[[Prototype]]</code>是在调用构造函数时自动创建的，这个指针即使在将原型修改为不同的对象也不会改变</p>
<p><img src="./%E5%8E%9F%E5%9E%8B.png"></p>
<p>重写原型会切断最初的原型与构造函数的连接，但实例仍与最初原型相连接（<strong>如前所述，实例只有指向原型的指针，没有指向构造函数的指针</strong>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>() <span class="comment">//实例先于重写prototype操作</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kyrie&#x27;</span>,</span><br><span class="line">  <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;constructor&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="title class_">Person</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p><img src="./%E5%8E%9F%E5%9E%8B2.png"></p>
<h4 id="原型的问题"><a href="#原型的问题" class="headerlink" title="原型的问题"></a>原型的问题</h4><p>原型模式也不是没有问题。首先，它弱化了向构造函数传递初始化参数的能力，但这不是重点。<br>如前所述，原型上的所有属性和方法都是共享的，包含原始值的属性可以通过在实例中添加同名属性来屏蔽，但问题处在了包含引用值的属性</p>
<p>来看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">constructor</span>: <span class="title class_">Person</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kyrie&#x27;</span>,</span><br><span class="line">  <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">friends</span>: [<span class="string">&#x27;kd&#x27;</span>, <span class="string">&#x27;harden&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line">p1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&#x27;james&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">friends</span>);<span class="comment">//[ &#x27;kd&#x27;, &#x27;harden&#x27;, &#x27;james&#x27; ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">friends</span>);<span class="comment">//[ &#x27;kd&#x27;, &#x27;harden&#x27;, &#x27;james&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">friends</span> === p2.<span class="property">friends</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，Person的原型上有一个friends属性，他是一个数组。现在实例p1向数组中添加了一项，因为这个数组存在原型对象上，所以p2的friends也发生了改变。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>面向对象语言支持两种继承：接口继承 和 实现继承。前者只继承方法签名，这在JS中显然不可能实现；后者继承实际的方法。<br>实现继承是ECMAScript唯一支持的继承方式，这主要通过原型链实现</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>其基本思想就是通过原型继承多个引用类型的属性和方法。<br>每个构造函数都会有一个原型对象，原型对象的constructor又指回构造函数，而实例由一个内部指针(<code>__proto__</code>)指向原型。</p>
<p>那如果原型是另一个类型的实例呢？</p>
<p>这就意味着原型有一个内部指针指向另一个原型，相应的，另一个原型也有一个constructor指向另一个构造函数。</p>
<p>这样就在原型和实例之间形成了一条原型链。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SuperType构造函数以及原型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;kyrie&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">print</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SubType构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">29</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SubType的原型重写为SuperType的实例</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//为SubType的原型添加方法</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">say</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建SubType的实例</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">SubType</span>()</span><br><span class="line"></span><br><span class="line">s.<span class="title function_">print</span>() <span class="comment">// kyrie</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，SubType通过重写原型对象为SuperType的实例，实现了对SuperType的继承。<br>这就意味着，SuperType实例可以访问的属性和方法，也存在于SubType.prototype中</p>
<p><img src="./%E5%8E%9F%E5%9E%8B%E9%93%BE2.png"></p>
<p>本例中实现继承的关键在于：SubType没有使用默认原型，而是把SuperType的实例当作他的原型。这样一来，SubType不仅可以访问到SuperType实例中继承方法和属性，还与SuperType的原型挂钩。</p>
<p>所以SubType的实例s可以通过内部的<code>[[prototype]]</code>访问到SubType.prototype，而SubType.prototype作为SuperType的实例，也可以通过内部的<code>[[prototype]]</code>访问到SuperType.prototype。</p>
<p>由于SubType的constructor被重写成指向SuperType，所以s.constructor也指向SuperType</p>
<h4 id="默认原型"><a href="#默认原型" class="headerlink" title="默认原型"></a>默认原型</h4><p>实际上，原型链还有一环。任何函数的默认原型都是Object的实例，也就意味着这个实例也有一个属性指向Object.prototype。这就是为什么自定义类型可以继承Object中的方法</p>
<p>所以在上面的例子中，SuperType.prototype实际上是Object的一个实例，所以它内部有一个指针指向Object.prototype。这就形成了完整的原型链</p>
<h4 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h4><p>向前面原型中的问题一样，原型链也存在 在原型中包含引用值的时候会有的问题。<br>原型链的第二个问题是：子类型在实例化时无法在不影响所有对象实例的情况下给父类型的构造函数传参。<br>这就导致了原型链不会被单独使用</p>
<h3 id="盗用构造函数"><a href="#盗用构造函数" class="headerlink" title="盗用构造函数"></a>盗用构造函数</h3><p>为了解决原型包含引用值的继承问题，有一种叫盗用构造函数的方法开始流行。<br>其基本思路很简单：在子类构造函数中调用父类构造函数，可以使用<code>apply()</code>或<code>call()</code>方法以新创建的对象为上下文执行构造函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SuperType构造函数以及原型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">frineds</span> = [<span class="string">&#x27;kd&#x27;</span>, <span class="string">&#x27;harden&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// SubType构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建SubType的实例</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="title class_">SubType</span>()</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="keyword">new</span> <span class="title class_">SubType</span>()</span><br><span class="line"></span><br><span class="line">s1.<span class="property">frineds</span>.<span class="title function_">push</span>(<span class="string">&#x27;kyrie&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">frineds</span>); <span class="comment">//[ &#x27;kd&#x27;, &#x27;harden&#x27;, &#x27;kyrie&#x27; ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s2.<span class="property">frineds</span>); <span class="comment">//[ &#x27;kd&#x27;, &#x27;harden&#x27; ]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面代码中的SubType函数就是盗用构造函数的调用，通过使用<code>apply</code>或<code>call</code>,SuperType构造函数在为SubType的实例创建的新对象的上下文中执行了。结果就是每个实例都会有自己的属性与方法</p>
<h4 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h4><p>相比于原型链，盗用构造函数的优点在于可以在子类构造函数中向父类构造函数传参</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SuperType构造函数以及原型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SubType构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, <span class="number">29</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">SubType</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">age</span>); <span class="comment">//29</span></span><br></pre></td></tr></table></figure>

<h4 id="盗用构造函数的问题"><a href="#盗用构造函数的问题" class="headerlink" title="盗用构造函数的问题"></a>盗用构造函数的问题</h4><p>盗用构造函数的主要缺点，也就是构造函数模式的问题：必须在构造函数内定义方法，这些方法不能重写。<br>此外，子类也不能访问父类原型上定义的方法，因为所有类型都用的是构造函数模式。所以也不会单独使用它</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承综合了原型链和盗用构造函数，基本原理是：使用原型链继承原型上的属性和方法，使用盗用构造函数继承实例上的属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SuperType构造函数以及原型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">frineds</span> = [<span class="string">&#x27;kd&#x27;</span>, <span class="string">&#x27;harden&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">print</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SubType构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SubType的原型重写为SuperType的实例</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//为SubType的原型添加方法</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建SubType的实例</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&#x27;kyrie&#x27;</span>, <span class="number">29</span>)</span><br><span class="line"></span><br><span class="line">s1.<span class="title function_">sayAge</span>() <span class="comment">//29</span></span><br><span class="line">s1.<span class="title function_">print</span>() <span class="comment">// kyrie</span></span><br><span class="line"></span><br><span class="line">s1.<span class="property">frineds</span>.<span class="title function_">push</span>(<span class="string">&#x27;james&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">frineds</span>); <span class="comment">//[ &#x27;kd&#x27;, &#x27;harden&#x27;, &#x27;james&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&#x27;curry&#x27;</span>, <span class="number">34</span>)</span><br><span class="line"></span><br><span class="line">s2.<span class="title function_">sayAge</span>() <span class="comment">//34</span></span><br><span class="line">s2.<span class="title function_">print</span>() <span class="comment">//curry</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s2.<span class="property">frineds</span>); <span class="comment">//[ &#x27;kd&#x27;, &#x27;harden&#x27; ]</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中。SuperType构造函数上定义了name和frineds两个属性，在他的原型上定义了一个print方法。<br>SubType构造函数盗用了SuperType构造函数，传入name参数，然后又定义了自己的属性age，SubType的原型也被重写为了SuperType的实例。原型重写之后在原型上添加了一个sayAge方法。</p>
<p>组合式继承是JS中使用最多的继承模式。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>不难看出，前面实现继承的代码看起来十分冗长混乱。为此ES6新引入<code>class</code>关键字来定义类。</p>
<h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p>与函数相似，定义类有两种方法：类声明 和 类表达式，都要使用class关键字</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"><span class="comment">//类表达式</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Person</span> = <span class="keyword">class</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>与函数声明不同的是，类声明不会声明提升</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数声明可以声明提升</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fn); <span class="comment">//[Function: fn]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//类声明不能声明提升</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>); <span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>类受块级作用域的限制</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>); <span class="comment">//[class Person]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>); <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>

<h3 id="类的构成"><a href="#类的构成" class="headerlink" title="类的构成"></a>类的构成</h3><p>类可以包含 构造函数，实例方法，获取函数，设置函数和静态方法，<strong>但这些都不是必须的，定义类时按需要使用，空的类定义照样有效</strong><br>下面是一些类定义的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">c1</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">c2</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">c3</span> &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">getName</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类表达式的名称是可以访问的，通过name属性访问，当不能在类表达式作用域外访问这个属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Class1</span> = <span class="keyword">class</span> <span class="title class_">c1</span> &#123;</span><br><span class="line">  <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Class1</span>.<span class="property">name</span>, c1.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Class1</span>()</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">print</span>() <span class="comment">//c1 c1</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c1.<span class="property">name</span>); <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>
<h3 id="类构造函数"><a href="#类构造函数" class="headerlink" title="类构造函数"></a>类构造函数</h3><p>constructor关键字用于在类中创建类的构造函数。构造函数的定义不是必须的。</p>
<p>使用new关键字实例化类的操作 等同于 使用new关键字调用构造函数</p>
<p>使用new调用类的构造函数会执行以下操作：</p>
<ol>
<li>在内存中创建一个对象</li>
<li>新对象的内部<code>[[prototype]]</code>执行构造函数的prototype属性</li>
<li>构造函数内部的this赋值为这个对象</li>
<li>执行构造函数中的代码</li>
<li>返回创建的新对象</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Person类实例化了一个对象&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当构造函数不传参时，括号可以不写</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>() <span class="comment">//Person类实例化了一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;名字是：&#x27;</span>+<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;cqy&#x27;</span>) <span class="comment">//名字是：cqy</span></span><br></pre></td></tr></table></figure>

<p>ECMAScript中没有正式定义类这个类型，所以类只是一个特殊的函数。可以通过<code>typeof</code>操作符检测类标识符，来说明他是一个函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Person</span>); <span class="comment">//function</span></span><br></pre></td></tr></table></figure>
<p>如前所述，类本身具有和普通构造函数一样的行为。在类的上下文中，类本身在使用new调用时就被当成构造函数。<br>重点在于，类中的constructor方法<strong>不会被</strong>当作构造函数。在对他使用instanceof操作符时返回false，但是在创建实例时，将类构造函数（使用点语法点出来）当作普通构造函数使用，instanceof操作符返回true</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>.<span class="property">constructor</span>); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>.<span class="title function_">constructor</span>(<span class="params"></span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2 <span class="keyword">instanceof</span> <span class="title class_">Person</span>.<span class="property">constructor</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="实例，原型和类成员"><a href="#实例，原型和类成员" class="headerlink" title="实例，原型和类成员"></a>实例，原型和类成员</h3><p>类的语法可以很好的定义应该存在于实例上的成员，应该存在于原型上的成员，还有应该存在于类本身的成员</p>
<h4 id="实例成员"><a href="#实例成员" class="headerlink" title="实例成员"></a>实例成员</h4><p>每次通过new关键字调用类标识符时，都会执行类构造函数。可以在这个函数内部为创建的实例添加“自有”属性。</p>
<p>每一个实例都对应一个唯一的成员对象，这意味着所有成员都不会在原型上共享</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">print</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;kyrie&#x27;</span>)</span><br><span class="line">p1.<span class="title function_">print</span>() <span class="comment">//kyrie</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;harden&#x27;</span>)</span><br><span class="line">p2.<span class="title function_">print</span>() <span class="comment">//harden</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">print</span> === p2.<span class="property">print</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h4 id="原型方法和访问器"><a href="#原型方法和访问器" class="headerlink" title="原型方法和访问器"></a>原型方法和访问器</h4><p>为了方便在实例间共享方法，类把在类块中定义的方法作为原型方法，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="comment">//在类块中定义的所有内容都会定义在类的原型上</span></span><br><span class="line">  <span class="title function_">show</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;show&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">show</span>() <span class="comment">//show</span></span><br></pre></td></tr></table></figure>
<p>但不可以在类块中给原型添加原始值或对象作为成员数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sex</span> = <span class="string">&#x27;man&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">sex</span>);</span><br></pre></td></tr></table></figure>

<p>类也支持获取和设置访问器，语法与行为跟普通对象一样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get被调用&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name_</span></span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set被调用&#x27;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name_</span> = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line">p.<span class="property">name</span> = <span class="string">&#x27;kyrie&#x27;</span> <span class="comment">//set被调用</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>); <span class="comment">//get被调用 kyrie</span></span><br></pre></td></tr></table></figure>

<h4 id="静态类方法"><a href="#静态类方法" class="headerlink" title="静态类方法"></a>静态类方法</h4><p>这些方法通常用于执行不特定于实例的操作，也不要求存在类的实例。<br>每个类上只能有一个静态成员，静态成员使用<code>static</code>关键字作为前缀。<br>在静态成员在，this引用类自身。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是静态成员&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">print</span>() <span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">print</span>() <span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">print</span>() <span class="comment">//我是静态成员</span></span><br></pre></td></tr></table></figure>

<h3 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h3><p>ES6提供了类继承机制，但其本质仍是原型链</p>
<h4 id="继承基础"><a href="#继承基础" class="headerlink" title="继承基础"></a>继承基础</h4><p>ES6支持单继承。使用<code>extends</code>关键字，可以继承任何拥有<code>[[construct]]</code>和原型的对象。也就是说可以继承类或者普通构造函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Student</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s <span class="keyword">instanceof</span> <span class="title class_">Student</span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">//true</span></span><br><span class="line">------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> () &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Student</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s <span class="keyword">instanceof</span> <span class="title class_">Student</span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>类和原型上的方法在派生类中也可以访问，this反映调用当前方法的实例或类</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">print</span>() <span class="comment">//Person &#123;&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Student</span>()</span><br><span class="line"></span><br><span class="line">s.<span class="title function_">print</span>() <span class="comment">//Student &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="super"><a href="#super" class="headerlink" title="super()"></a>super()</h4><p>派生类可以通过<code>super</code>关键字引用它们的原型，super关键字只能在派生类中使用，且只能在构造函数，实例方法和静态方法中使用。</p>
<p>在类构造函数中使用super会调用父类构造函数，如果父类构造函数需要传参，可以通过super传入</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sex</span> = <span class="string">&#x27;man&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//不能再super()之前引用this，会报错</span></span><br><span class="line">    <span class="variable language_">super</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">//true</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">//Student &#123; sex: &#x27;man&#x27; &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Student</span>()</span><br></pre></td></tr></table></figure>

<p>使用super调用父类的静态方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Person&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">myPrint</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">print</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Student</span>.<span class="title function_">myPrint</span>() <span class="comment">//Person</span></span><br></pre></td></tr></table></figure>

<p><strong>super的几个注意点：</strong></p>
<ol>
<li>super不能单独使用，要么在构造函数中调用它，要么用它调用静态方法</li>
<li>在构造函数中调用super，super会调用父类构造函数，将返回的实例赋值给this</li>
<li>在构造函数中，不能在调用super之前引用this</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小c只会突破</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://kyriecqy.github.io/2022/05/22/JS%E9%AB%98%E7%BA%A7(2)/">https://kyriecqy.github.io/2022/05/22/JS%E9%AB%98%E7%BA%A7(2)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://kyriecqy.github.io" target="_blank">kyrie C</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JS-%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/">JS 基础语言</a></div><div class="post_share"><div class="social-share" data-image="/images/logo.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/29/Vue%E6%BA%90%E7%A0%81%E4%B9%8BAST%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/"><img class="prev-cover" src="/images/logo.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Vue源码之AST抽象语法树</div></div></a></div><div class="next-post pull-right"><a href="/2022/05/15/Vue%E6%BA%90%E7%A0%81%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"><img class="next-cover" src="/images/logo.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Vue源码之数据响应式原理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/04/22/JS%E9%AB%98%E7%BA%A7(1)/" title="JS高级（1）"><img class="cover" src="/images/logo.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-22</div><div class="title">JS高级（1）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/irving.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">小c只会突破</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/kyriecqy"><i class="fab fa-github"></i><span>前往Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/kyriecqy" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is kyrie C's Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Level-2"><span class="toc-number">1.</span> <span class="toc-text">Level 2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JSON"><span class="toc-number">1.1.</span> <span class="toc-text">JSON</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">1.1.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.2.</span> <span class="toc-text">JSON对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E9%80%89%E9%A1%B9"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">序列化选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E9%80%89%E9%A1%B9"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">解析选项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.2.</span> <span class="toc-text">执行上下文和作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">1.3.1.</span> <span class="toc-text">变量声明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.4.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.1.</span> <span class="toc-text">属性的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B1%9E%E6%80%A7"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">数据属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%99%A8%E5%B1%9E%E6%80%A7"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">访问器属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E5%B1%9E%E6%80%A7%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">读取属性的特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.4.2.</span> <span class="toc-text">合并对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BA%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95"><span class="toc-number">1.4.3.</span> <span class="toc-text">增强对象语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84"><span class="toc-number">1.4.4.</span> <span class="toc-text">对象解构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E8%A7%A3%E6%9E%84"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">嵌套解构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%8C%B9%E9%85%8D"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">函数参数匹配</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.5.</span> <span class="toc-text">创建对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.1.</span> <span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.2.</span> <span class="toc-text">构造函数模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.3.</span> <span class="toc-text">原型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">理解原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%B1%82%E7%BA%A7"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">原型层级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E4%B8%8E-in-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">原型与 in 操作符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.5.4.</span> <span class="toc-text">对象迭代</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%8E%9F%E5%9E%8B%E8%AF%AD%E6%B3%95"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">其他原型语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%8A%A8%E6%80%81%E6%80%A7"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">原型的动态性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.4.3.</span> <span class="toc-text">原型的问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.6.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">1.6.1.</span> <span class="toc-text">原型链</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8E%9F%E5%9E%8B"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">默认原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">原型链的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%97%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.2.</span> <span class="toc-text">盗用构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">传递参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%97%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">盗用构造函数的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-number">1.6.3.</span> <span class="toc-text">组合继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">1.7.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.7.1.</span> <span class="toc-text">类的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%9E%84%E6%88%90"><span class="toc-number">1.7.2.</span> <span class="toc-text">类的构成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.3.</span> <span class="toc-text">类构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%B1%BB%E6%88%90%E5%91%98"><span class="toc-number">1.7.4.</span> <span class="toc-text">实例，原型和类成员</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">实例成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95%E5%92%8C%E8%AE%BF%E9%97%AE%E5%99%A8"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">原型方法和访问器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.4.3.</span> <span class="toc-text">静态类方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF-1"><span class="toc-number">1.7.5.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%9F%BA%E7%A1%80"><span class="toc-number">1.7.5.1.</span> <span class="toc-text">继承基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#super"><span class="toc-number">1.7.5.2.</span> <span class="toc-text">super()</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/06/04/Webpack%E9%85%8D%E7%BD%AEVue-cli/" title="Webpack配置Vue-cli"><img src="/images/logo.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Webpack配置Vue-cli"/></a><div class="content"><a class="title" href="/2022/06/04/Webpack%E9%85%8D%E7%BD%AEVue-cli/" title="Webpack配置Vue-cli">Webpack配置Vue-cli</a><time datetime="2022-06-04T02:34:22.000Z" title="发表于 2022-06-04 10:34:22">2022-06-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/02/Webpack%E9%AB%98%E7%BA%A7/" title="Webpack高级"><img src="/images/logo.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Webpack高级"/></a><div class="content"><a class="title" href="/2022/06/02/Webpack%E9%AB%98%E7%BA%A7/" title="Webpack高级">Webpack高级</a><time datetime="2022-06-02T12:42:50.000Z" title="发表于 2022-06-02 20:42:50">2022-06-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/31/Webpack%E5%9F%BA%E7%A1%80/" title="Webpack基础"><img src="/images/logo.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Webpack基础"/></a><div class="content"><a class="title" href="/2022/05/31/Webpack%E5%9F%BA%E7%A1%80/" title="Webpack基础">Webpack基础</a><time datetime="2022-05-31T11:31:19.000Z" title="发表于 2022-05-31 19:31:19">2022-05-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/30/Vue%E6%BA%90%E7%A0%81%E4%B9%8B%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" title="Vue源码之指令与生命周期"><img src="/images/logo.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vue源码之指令与生命周期"/></a><div class="content"><a class="title" href="/2022/05/30/Vue%E6%BA%90%E7%A0%81%E4%B9%8B%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" title="Vue源码之指令与生命周期">Vue源码之指令与生命周期</a><time datetime="2022-05-30T11:53:52.000Z" title="发表于 2022-05-30 19:53:52">2022-05-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/29/Vue%E6%BA%90%E7%A0%81%E4%B9%8BAST%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/" title="Vue源码之AST抽象语法树"><img src="/images/logo.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vue源码之AST抽象语法树"/></a><div class="content"><a class="title" href="/2022/05/29/Vue%E6%BA%90%E7%A0%81%E4%B9%8BAST%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/" title="Vue源码之AST抽象语法树">Vue源码之AST抽象语法树</a><time datetime="2022-05-29T05:52:21.000Z" title="发表于 2022-05-29 13:52:21">2022-05-29</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/images/bg3.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 By 小c只会突破</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>